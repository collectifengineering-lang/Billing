"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/zoho.ts":
/*!*********************!*\
  !*** ./lib/zoho.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchInvoices: function() { return /* binding */ fetchInvoices; },\n/* harmony export */   fetchProjects: function() { return /* binding */ fetchProjects; },\n/* harmony export */   zohoService: function() { return /* binding */ zohoService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nclass ZohoService {\n    _startAutoRefresh() {\n        // Clear any existing timer\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n        }\n        // Set up automatic refresh every 45 minutes\n        this.autoRefreshTimer = setInterval(async ()=>{\n            try {\n                console.log(\"Auto-refreshing Zoho token (45-minute interval)...\");\n                this.lastRefreshTime = Date.now(); // Track when refresh was triggered\n                await this.forceRefreshToken();\n                console.log(\"Auto-refresh completed successfully\");\n            } catch (error) {\n                console.error(\"Auto-refresh failed:\", error);\n            }\n        }, this.AUTO_REFRESH_INTERVAL);\n        // Set initial refresh time\n        this.lastRefreshTime = Date.now();\n        console.log(\"Automatic Zoho token refresh started (every 45 minutes)\");\n    }\n    _stopAutoRefresh() {\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n            this.autoRefreshTimer = null;\n            console.log(\"Automatic Zoho token refresh stopped\");\n        }\n    }\n    async getAccessToken() {\n        // Check if token is still valid (with buffer)\n        if (this.accessToken && Date.now() < this.tokenExpiry - this.TOKEN_REFRESH_BUFFER) {\n            return this.accessToken;\n        }\n        // If there's already a refresh in progress, wait for it\n        if (this.refreshPromise) {\n            return this.refreshPromise;\n        }\n        // Start a new refresh\n        this.refreshPromise = this.refreshAccessToken();\n        try {\n            const token = await this.refreshPromise;\n            return token;\n        } finally{\n            this.refreshPromise = null;\n        }\n    }\n    async refreshAccessToken() {\n        try {\n            console.log(\"Refreshing Zoho access token...\");\n            // Create form data for the request\n            const formData = new URLSearchParams();\n            formData.append(\"refresh_token\", \"1000.4bf26c4881dfba83aae32546453d662d.a9353e91362a18c457b5cbec86b10ed2\" || 0);\n            formData.append(\"client_id\", \"1000.8RL8WMTDXS0WIP2EJF2XUS6NDSLQEP\" || 0);\n            formData.append(\"client_secret\", \"8a7ee3c04f0a0d860dd215c4449deab9bf15d1d00b\" || 0);\n            formData.append(\"grant_type\", \"refresh_token\");\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"https://accounts.zoho.com/oauth/v2/token\", formData, {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n            this.accessToken = response.data.access_token;\n            this.tokenExpiry = Date.now() + response.data.expires_in * 1000;\n            console.log(\"Token refreshed successfully. Expires in \".concat(Math.round(response.data.expires_in / 60), \" minutes\"));\n            return this.accessToken;\n        } catch (error) {\n            console.error(\"Error refreshing Zoho access token:\", error);\n            throw new Error(\"Failed to authenticate with Zoho\");\n        }\n    }\n    async makeRequest(endpoint) {\n        try {\n            const token = await this.getAccessToken();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://www.zohoapis.com/books/v3/\".concat(endpoint), {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(token),\n                    \"Content-Type\": \"application/json\"\n                },\n                params: {\n                    organization_id: \"652094923\"\n                }\n            });\n            return response.data;\n        } catch (error) {\n            var _error_response, _error_response1;\n            // If we get a 401, try refreshing the token once\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401) {\n                console.log(\"Token expired, refreshing...\");\n                // Clear the current token and force a refresh\n                this.accessToken = null;\n                this.tokenExpiry = 0;\n                try {\n                    const newToken = await this.forceRefreshToken();\n                    // Retry the request with the new token\n                    const retryResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://www.zohoapis.com/books/v3/\".concat(endpoint), {\n                        headers: {\n                            \"Authorization\": \"Bearer \".concat(newToken),\n                            \"Content-Type\": \"application/json\"\n                        },\n                        params: {\n                            organization_id: \"652094923\"\n                        }\n                    });\n                    console.log(\"Request retry successful after token refresh\");\n                    return retryResponse.data;\n                } catch (refreshError) {\n                    console.error(\"Failed to refresh token or retry request:\", refreshError);\n                    throw new Error(\"Zoho API authentication failed after token refresh: \".concat(endpoint));\n                }\n            }\n            // Handle other HTTP errors\n            if ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) {\n                var _error_response_data;\n                console.error(\"Zoho API error \".concat(error.response.status, \" for \").concat(endpoint, \":\"), error.response.data);\n                throw new Error(\"Zoho API error \".concat(error.response.status, \": \").concat(((_error_response_data = error.response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || \"Unknown error\"));\n            }\n            console.error(\"Error making Zoho request to \".concat(endpoint, \":\"), error);\n            throw new Error(\"Failed to fetch data from Zoho: \".concat(endpoint));\n        }\n    }\n    async getProjects() {\n        try {\n            let allProjects = [];\n            let page = 1;\n            const perPage = 200;\n            while(true){\n                var _data_projects;\n                const data = await this.makeRequest(\"projects?page=\".concat(page, \"&per_page=\").concat(perPage));\n                const projects = ((_data_projects = data.projects) === null || _data_projects === void 0 ? void 0 : _data_projects.map((project)=>{\n                    // Log the first project to see available fields\n                    if (page === 1 && allProjects.length === 0) {\n                        console.log(\"Sample Zoho project data:\", JSON.stringify(project, null, 2));\n                    }\n                    return {\n                        project_id: project.project_id,\n                        project_name: project.project_name || project.name || \"\",\n                        description: project.description || \"\",\n                        status: project.status || \"active\",\n                        start_date: project.start_date || \"\",\n                        end_date: project.end_date || \"\",\n                        budget_amount: project.budget_amount || 0,\n                        rate_per_hour: project.rate_per_hour || 0,\n                        customer_id: project.customer_id || \"\",\n                        customer_name: project.customer_name || \"\",\n                        signed_fee: undefined\n                    };\n                })) || [];\n                allProjects = allProjects.concat(projects);\n                // Check if we've reached the end\n                if (projects.length < perPage) {\n                    break;\n                }\n                page++;\n            }\n            console.log(\"Fetched \".concat(allProjects.length, \" projects from Zoho\"));\n            return allProjects;\n        } catch (error) {\n            console.error(\"Error fetching projects:\", error);\n            return [];\n        }\n    }\n    async getProjectsWithRevenueBudget() {\n        try {\n            console.log(\"Fetching projects with revenue budget data...\");\n            const projects = await this.getProjects();\n            // Log projects that have revenue_budget data\n            const projectsWithRevenueBudget = projects.filter((project)=>{\n                const hasRevenueBudget = project.signed_fee && project.signed_fee > 0;\n                if (hasRevenueBudget) {\n                    console.log(\"Project \".concat(project.project_name, \" has revenue budget: $\").concat(project.signed_fee));\n                }\n                return hasRevenueBudget;\n            });\n            console.log(\"Found \".concat(projectsWithRevenueBudget.length, \" projects with revenue budget data\"));\n            return projects;\n        } catch (error) {\n            console.error(\"Error fetching projects with revenue budget:\", error);\n            return [];\n        }\n    }\n    async debugProjectFields() {\n        try {\n            console.log(\"Debugging Zoho project fields...\");\n            const data = await this.makeRequest(\"projects?page=1&per_page=5\");\n            if (data.projects && data.projects.length > 0) {\n                console.log(\"Available fields in Zoho project response:\");\n                const sampleProject = data.projects[0];\n                Object.keys(sampleProject).forEach((key)=>{\n                    console.log(\"  \".concat(key, \": \").concat(sampleProject[key], \" (\").concat(typeof sampleProject[key], \")\"));\n                });\n                // Check specifically for revenue_budget\n                if (sampleProject.revenue_budget !== undefined) {\n                    console.log(\"✅ Found revenue_budget field: \".concat(sampleProject.revenue_budget));\n                } else {\n                    console.log(\"❌ revenue_budget field not found in Zoho response\");\n                    console.log(\"Available budget-related fields:\");\n                    Object.keys(sampleProject).forEach((key)=>{\n                        if (key.toLowerCase().includes(\"budget\") || key.toLowerCase().includes(\"revenue\")) {\n                            console.log(\"  \".concat(key, \": \").concat(sampleProject[key]));\n                        }\n                    });\n                }\n            } else {\n                console.log(\"No projects found in Zoho response\");\n            }\n        } catch (error) {\n            console.error(\"Error debugging project fields:\", error);\n        }\n    }\n    async getProjectsWithEstimates() {\n        try {\n            const projects = await this.getProjects();\n            // For the first few projects, try to get estimates to see if that contains the signed fee\n            const projectsWithEstimates = await Promise.all(projects.slice(0, 5).map(async (project)=>{\n                try {\n                    const estimates = await this.getProjectEstimates(project.project_id);\n                    const totalEstimateAmount = estimates.reduce((sum, estimate)=>sum + (estimate.total || 0), 0);\n                    console.log(\"Project \".concat(project.project_name, \" estimates:\"), estimates.length, \"total amount:\", totalEstimateAmount);\n                    return {\n                        ...project,\n                        signed_fee: project.signed_fee || totalEstimateAmount || 0\n                    };\n                } catch (error) {\n                    console.error(\"Error fetching estimates for project \".concat(project.project_id, \":\"), error);\n                    return project;\n                }\n            }));\n            // Return all projects, with the first 5 having updated signed fees from estimates\n            return [\n                ...projectsWithEstimates,\n                ...projects.slice(5)\n            ];\n        } catch (error) {\n            console.error(\"Error fetching projects with estimates:\", error);\n            return [];\n        }\n    }\n    async getProjectsWithInvoiceTotals() {\n        try {\n            const [projects, invoices] = await Promise.all([\n                this.getProjects(),\n                this.getInvoices()\n            ]);\n            // Calculate signed fee as total of all invoices for each project\n            const projectsWithInvoiceTotals = projects.map((project)=>{\n                const projectInvoices = invoices.filter((invoice)=>invoice.project_id === project.project_id);\n                const totalInvoiceAmount = projectInvoices.reduce((sum, invoice)=>sum + invoice.amount, 0);\n                console.log(\"Project \".concat(project.project_name, \" invoices:\"), projectInvoices.length, \"total amount:\", totalInvoiceAmount);\n                return {\n                    ...project,\n                    signed_fee: project.signed_fee || totalInvoiceAmount || 0\n                };\n            });\n            return projectsWithInvoiceTotals;\n        } catch (error) {\n            console.error(\"Error fetching projects with invoice totals:\", error);\n            return [];\n        }\n    }\n    async getInvoices() {\n        try {\n            var _data_invoices;\n            const data = await this.makeRequest(\"invoices\");\n            return ((_data_invoices = data.invoices) === null || _data_invoices === void 0 ? void 0 : _data_invoices.map((invoice)=>({\n                    invoice_id: invoice.invoice_id,\n                    project_id: invoice.project_id,\n                    invoice_number: invoice.invoice_number,\n                    date: invoice.date,\n                    amount: invoice.total,\n                    status: invoice.status,\n                    billed_amount: invoice.billed_amount || 0,\n                    unbilled_amount: invoice.unbilled_amount || 0\n                }))) || [];\n        } catch (error) {\n            console.error(\"Error fetching invoices:\", error);\n            return [];\n        }\n    }\n    async getProjectInvoices(projectId) {\n        try {\n            var _data_invoices;\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/invoices\"));\n            return ((_data_invoices = data.invoices) === null || _data_invoices === void 0 ? void 0 : _data_invoices.map((invoice)=>({\n                    invoice_id: invoice.invoice_id,\n                    project_id: invoice.project_id,\n                    invoice_number: invoice.invoice_number,\n                    date: invoice.date,\n                    amount: invoice.total,\n                    status: invoice.status,\n                    billed_amount: invoice.billed_amount || 0,\n                    unbilled_amount: invoice.unbilled_amount || 0\n                }))) || [];\n        } catch (error) {\n            console.error(\"Error fetching project invoices:\", error);\n            return [];\n        }\n    }\n    async getProjectDetails(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId));\n            console.log(\"Project \".concat(projectId, \" details:\"), JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching project details:\", error);\n            return null;\n        }\n    }\n    async getProjectEstimates(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/estimates\"));\n            console.log(\"Project \".concat(projectId, \" estimates:\"), JSON.stringify(data, null, 2));\n            return data.estimates || [];\n        } catch (error) {\n            console.error(\"Error fetching project estimates:\", error);\n            return [];\n        }\n    }\n    async getProjectContracts(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/contracts\"));\n            console.log(\"Project \".concat(projectId, \" contracts:\"), JSON.stringify(data, null, 2));\n            return data.contracts || [];\n        } catch (error) {\n            console.error(\"Error fetching project contracts:\", error);\n            return [];\n        }\n    }\n    // New method to get Profit & Loss statement\n    async getProfitAndLoss(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"reports/profitandloss?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Profit & Loss data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Profit & Loss:\", error);\n            return null;\n        }\n    }\n    // New method to get Cash Flow statement\n    async getCashFlow(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"reports/cashflow?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Cash Flow data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Cash Flow:\", error);\n            return null;\n        }\n    }\n    // New method to get Balance Sheet\n    async getBalanceSheet(date) {\n        try {\n            const data = await this.makeRequest(\"reports/balancesheet?date=\".concat(date));\n            console.log(\"Balance Sheet data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Balance Sheet:\", error);\n            return null;\n        }\n    }\n    // New method to get Chart of Accounts\n    async getChartOfAccounts() {\n        try {\n            const data = await this.makeRequest(\"chartofaccounts\");\n            console.log(\"Chart of Accounts data:\", JSON.stringify(data, null, 2));\n            return data.chartofaccounts || [];\n        } catch (error) {\n            console.error(\"Error fetching Chart of Accounts:\", error);\n            return [];\n        }\n    }\n    // New method to get Journal Entries for a date range\n    async getJournalEntries(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"journalentries?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Journal Entries data:\", JSON.stringify(data, null, 2));\n            return data.journalentries || [];\n        } catch (error) {\n            console.error(\"Error fetching Journal Entries:\", error);\n            return [];\n        }\n    }\n    // New method to get comprehensive financial metrics\n    async getFinancialMetrics(startDate, endDate) {\n        try {\n            var _plData_revenue, _plData_expenses, _plData_operating_expenses, _plData_operating_expenses1, _bsData_current_assets, _bsData_current_liabilities, _bsData_current_assets1;\n            const [plData, cfData, bsData] = await Promise.all([\n                this.getProfitAndLoss(startDate, endDate),\n                this.getCashFlow(startDate, endDate),\n                this.getBalanceSheet(endDate)\n            ]);\n            // Extract financial metrics from the responses\n            const revenue = (plData === null || plData === void 0 ? void 0 : (_plData_revenue = plData.revenue) === null || _plData_revenue === void 0 ? void 0 : _plData_revenue.total) || 0;\n            const expenses = (plData === null || plData === void 0 ? void 0 : (_plData_expenses = plData.expenses) === null || _plData_expenses === void 0 ? void 0 : _plData_expenses.total) || 0;\n            const grossProfit = revenue - expenses;\n            // Calculate net profit (may need adjustment based on actual Zoho response structure)\n            const netProfit = grossProfit - ((plData === null || plData === void 0 ? void 0 : (_plData_operating_expenses = plData.operating_expenses) === null || _plData_operating_expenses === void 0 ? void 0 : _plData_operating_expenses.total) || 0);\n            const operatingIncome = grossProfit - ((plData === null || plData === void 0 ? void 0 : (_plData_operating_expenses1 = plData.operating_expenses) === null || _plData_operating_expenses1 === void 0 ? void 0 : _plData_operating_expenses1.total) || 0);\n            // Extract cash flow data\n            const cashFlow = (cfData === null || cfData === void 0 ? void 0 : cfData.net_cash_flow) || 0;\n            const accountsReceivable = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_assets = bsData.current_assets) === null || _bsData_current_assets === void 0 ? void 0 : _bsData_current_assets.accounts_receivable) || 0;\n            const accountsPayable = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_liabilities = bsData.current_liabilities) === null || _bsData_current_liabilities === void 0 ? void 0 : _bsData_current_liabilities.accounts_payable) || 0;\n            const cashBalance = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_assets1 = bsData.current_assets) === null || _bsData_current_assets1 === void 0 ? void 0 : _bsData_current_assets1.cash_and_bank) || 0;\n            return {\n                revenue,\n                expenses,\n                grossProfit,\n                netProfit,\n                operatingIncome,\n                cashFlow,\n                accountsReceivable,\n                accountsPayable,\n                cashBalance\n            };\n        } catch (error) {\n            console.error(\"Error fetching financial metrics:\", error);\n            // Return default values if API calls fail\n            return {\n                revenue: 0,\n                expenses: 0,\n                grossProfit: 0,\n                netProfit: 0,\n                operatingIncome: 0,\n                cashFlow: 0,\n                accountsReceivable: 0,\n                accountsPayable: 0,\n                cashBalance: 0\n            };\n        }\n    }\n    // Method to manually refresh token (for testing)\n    async forceRefreshToken() {\n        this.accessToken = null;\n        this.tokenExpiry = 0;\n        this.lastRefreshTime = Date.now(); // Track manual refresh time\n        await this.getAccessToken();\n    }\n    // Get token status for debugging\n    getTokenStatus() {\n        const now = Date.now();\n        return {\n            hasToken: !!this.accessToken,\n            expiresIn: this.tokenExpiry - now,\n            isExpired: now >= this.tokenExpiry\n        };\n    }\n    // Method to get auto-refresh status\n    getAutoRefreshStatus() {\n        const now = Date.now();\n        const timeSinceLastRefresh = now - this.lastRefreshTime;\n        const nextRefreshIn = Math.max(0, this.AUTO_REFRESH_INTERVAL - timeSinceLastRefresh);\n        return {\n            isActive: !!this.autoRefreshTimer,\n            nextRefreshIn\n        };\n    }\n    // Public method to start auto-refresh\n    enableAutoRefresh() {\n        this._startAutoRefresh();\n    }\n    // Public method to stop auto-refresh\n    disableAutoRefresh() {\n        this._stopAutoRefresh();\n    }\n    // Public method to get comprehensive status\n    getStatus() {\n        return {\n            ...this.getTokenStatus(),\n            autoRefresh: this.getAutoRefreshStatus()\n        };\n    }\n    constructor(){\n        this.accessToken = null;\n        this.tokenExpiry = 0;\n        this.refreshPromise = null;\n        this.TOKEN_REFRESH_BUFFER = 5 * 60 * 1000 // 5 minutes buffer\n        ;\n        this.autoRefreshTimer = null;\n        this.AUTO_REFRESH_INTERVAL = 45 * 60 * 1000 // 45 minutes\n        ;\n        this.lastRefreshTime = 0 // Track when auto-refresh was last triggered\n        ;\n        // Start automatic token refresh\n        this._startAutoRefresh();\n    }\n}\nconst zohoService = new ZohoService();\n// Export the functions that are being imported in page.tsx\nconst fetchProjects = async ()=>{\n    try {\n        console.log(\"Client: Fetching projects from API\");\n        const response = await fetch(\"/api/projects\");\n        const result = await response.json();\n        if (result.success) {\n            console.log(\"Client: Successfully fetched\", result.count, \"projects\");\n            return result.data;\n        } else {\n            console.error(\"Client: API returned error:\", result.error);\n            throw new Error(result.error);\n        }\n    } catch (error) {\n        console.error(\"Client: Error fetching projects:\", error);\n        throw error;\n    }\n};\nconst fetchInvoices = async ()=>{\n    try {\n        console.log(\"Client: Fetching invoices from API\");\n        const response = await fetch(\"/api/invoices\");\n        const result = await response.json();\n        if (result.success) {\n            console.log(\"Client: Successfully fetched\", result.count, \"invoices\");\n            return result.data;\n        } else {\n            console.error(\"Client: API returned error:\", result.error);\n            throw new Error(result.error);\n        }\n    } catch (error) {\n        console.error(\"Client: Error fetching invoices:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi96b2hvLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEI7QUFtQzFCLE1BQU1DO0lBY0lDLG9CQUEwQjtRQUNoQywyQkFBMkI7UUFDM0IsSUFBSSxJQUFJLENBQUNDLGdCQUFnQixFQUFFO1lBQ3pCQyxjQUFjLElBQUksQ0FBQ0QsZ0JBQWdCO1FBQ3JDO1FBRUEsNENBQTRDO1FBQzVDLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdFLFlBQVk7WUFDbEMsSUFBSTtnQkFDRkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ0MsZUFBZSxHQUFHQyxLQUFLQyxHQUFHLElBQUksbUNBQW1DO2dCQUN0RSxNQUFNLElBQUksQ0FBQ0MsaUJBQWlCO2dCQUM1QkwsUUFBUUMsR0FBRyxDQUFDO1lBQ2QsRUFBRSxPQUFPSyxPQUFPO2dCQUNkTixRQUFRTSxLQUFLLENBQUMsd0JBQXdCQTtZQUN4QztRQUNGLEdBQUcsSUFBSSxDQUFDQyxxQkFBcUI7UUFFN0IsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0wsZUFBZSxHQUFHQyxLQUFLQyxHQUFHO1FBQy9CSixRQUFRQyxHQUFHLENBQUM7SUFDZDtJQUVRTyxtQkFBeUI7UUFDL0IsSUFBSSxJQUFJLENBQUNYLGdCQUFnQixFQUFFO1lBQ3pCQyxjQUFjLElBQUksQ0FBQ0QsZ0JBQWdCO1lBQ25DLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUc7WUFDeEJHLFFBQVFDLEdBQUcsQ0FBQztRQUNkO0lBQ0Y7SUFFQSxNQUFjUSxpQkFBa0M7UUFDOUMsOENBQThDO1FBQzlDLElBQUksSUFBSSxDQUFDQyxXQUFXLElBQUlQLEtBQUtDLEdBQUcsS0FBTSxJQUFJLENBQUNPLFdBQVcsR0FBRyxJQUFJLENBQUNDLG9CQUFvQixFQUFHO1lBQ25GLE9BQU8sSUFBSSxDQUFDRixXQUFXO1FBQ3pCO1FBRUEsd0RBQXdEO1FBQ3hELElBQUksSUFBSSxDQUFDRyxjQUFjLEVBQUU7WUFDdkIsT0FBTyxJQUFJLENBQUNBLGNBQWM7UUFDNUI7UUFFQSxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDQSxjQUFjLEdBQUcsSUFBSSxDQUFDQyxrQkFBa0I7UUFDN0MsSUFBSTtZQUNGLE1BQU1DLFFBQVEsTUFBTSxJQUFJLENBQUNGLGNBQWM7WUFDdkMsT0FBT0U7UUFDVCxTQUFVO1lBQ1IsSUFBSSxDQUFDRixjQUFjLEdBQUc7UUFDeEI7SUFDRjtJQUVBLE1BQWNDLHFCQUFzQztRQUNsRCxJQUFJO1lBQ0ZkLFFBQVFDLEdBQUcsQ0FBQztZQUVaLG1DQUFtQztZQUNuQyxNQUFNZSxXQUFXLElBQUlDO1lBQ3JCRCxTQUFTRSxNQUFNLENBQUMsaUJBQWlCQyx3RUFBOEIsSUFBSTtZQUNuRUgsU0FBU0UsTUFBTSxDQUFDLGFBQWFDLHFDQUEwQixJQUFJO1lBQzNESCxTQUFTRSxNQUFNLENBQUMsaUJBQWlCQyw0Q0FBOEIsSUFBSTtZQUNuRUgsU0FBU0UsTUFBTSxDQUFDLGNBQWM7WUFFOUIsTUFBTU0sV0FBVyxNQUFNOUIsNkNBQUtBLENBQUMrQixJQUFJLENBQWdCLDRDQUE0Q1QsVUFBVTtnQkFDckdVLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDaEIsV0FBVyxHQUFHYyxTQUFTRyxJQUFJLENBQUNDLFlBQVk7WUFDN0MsSUFBSSxDQUFDakIsV0FBVyxHQUFHUixLQUFLQyxHQUFHLEtBQU1vQixTQUFTRyxJQUFJLENBQUNFLFVBQVUsR0FBRztZQUU1RDdCLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBc0YsT0FBMUM2QixLQUFLQyxLQUFLLENBQUNQLFNBQVNHLElBQUksQ0FBQ0UsVUFBVSxHQUFHLEtBQUk7WUFFbEcsT0FBTyxJQUFJLENBQUNuQixXQUFXO1FBQ3pCLEVBQUUsT0FBT0osT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMsdUNBQXVDQTtZQUNyRCxNQUFNLElBQUkwQixNQUFNO1FBQ2xCO0lBQ0Y7SUFFQSxNQUFjQyxZQUFZQyxRQUFnQixFQUFnQjtRQUN4RCxJQUFJO1lBQ0YsTUFBTW5CLFFBQVEsTUFBTSxJQUFJLENBQUNOLGNBQWM7WUFFdkMsTUFBTWUsV0FBVyxNQUFNOUIsNkNBQUtBLENBQUN5QyxHQUFHLENBQUMscUNBQThDLE9BQVRELFdBQVk7Z0JBQ2hGUixTQUFTO29CQUNQLGlCQUFpQixVQUFnQixPQUFOWDtvQkFDM0IsZ0JBQWdCO2dCQUNsQjtnQkFDQXFCLFFBQVE7b0JBQ05DLGlCQUFpQmxCLFdBQWdDO2dCQUNuRDtZQUNGO1lBRUEsT0FBT0ssU0FBU0csSUFBSTtRQUN0QixFQUFFLE9BQU9yQixPQUFZO2dCQUVmQSxpQkE4QkFBO1lBL0JKLGlEQUFpRDtZQUNqRCxJQUFJQSxFQUFBQSxrQkFBQUEsTUFBTWtCLFFBQVEsY0FBZGxCLHNDQUFBQSxnQkFBZ0JpQyxNQUFNLE1BQUssS0FBSztnQkFDbEN2QyxRQUFRQyxHQUFHLENBQUM7Z0JBRVosOENBQThDO2dCQUM5QyxJQUFJLENBQUNTLFdBQVcsR0FBRztnQkFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7Z0JBRW5CLElBQUk7b0JBQ0YsTUFBTTZCLFdBQVcsTUFBTSxJQUFJLENBQUNuQyxpQkFBaUI7b0JBRTdDLHVDQUF1QztvQkFDdkMsTUFBTW9DLGdCQUFnQixNQUFNL0MsNkNBQUtBLENBQUN5QyxHQUFHLENBQUMscUNBQThDLE9BQVRELFdBQVk7d0JBQ3JGUixTQUFTOzRCQUNQLGlCQUFpQixVQUFtQixPQUFUYzs0QkFDM0IsZ0JBQWdCO3dCQUNsQjt3QkFDQUosUUFBUTs0QkFDTkMsaUJBQWlCbEIsV0FBZ0M7d0JBQ25EO29CQUNGO29CQUVBbkIsUUFBUUMsR0FBRyxDQUFDO29CQUNaLE9BQU93QyxjQUFjZCxJQUFJO2dCQUMzQixFQUFFLE9BQU9lLGNBQWM7b0JBQ3JCMUMsUUFBUU0sS0FBSyxDQUFDLDZDQUE2Q29DO29CQUMzRCxNQUFNLElBQUlWLE1BQU0sdURBQWdFLE9BQVRFO2dCQUN6RTtZQUNGO1lBRUEsMkJBQTJCO1lBQzNCLEtBQUk1QixtQkFBQUEsTUFBTWtCLFFBQVEsY0FBZGxCLHVDQUFBQSxpQkFBZ0JpQyxNQUFNLEVBQUU7b0JBRWtDakM7Z0JBRDVETixRQUFRTSxLQUFLLENBQUMsa0JBQStDNEIsT0FBN0I1QixNQUFNa0IsUUFBUSxDQUFDZSxNQUFNLEVBQUMsU0FBZ0IsT0FBVEwsVUFBUyxNQUFJNUIsTUFBTWtCLFFBQVEsQ0FBQ0csSUFBSTtnQkFDN0YsTUFBTSxJQUFJSyxNQUFNLGtCQUE0QzFCLE9BQTFCQSxNQUFNa0IsUUFBUSxDQUFDZSxNQUFNLEVBQUMsTUFBb0QsT0FBaERqQyxFQUFBQSx1QkFBQUEsTUFBTWtCLFFBQVEsQ0FBQ0csSUFBSSxjQUFuQnJCLDJDQUFBQSxxQkFBcUJxQyxPQUFPLEtBQUk7WUFDOUY7WUFFQTNDLFFBQVFNLEtBQUssQ0FBQyxnQ0FBeUMsT0FBVDRCLFVBQVMsTUFBSTVCO1lBQzNELE1BQU0sSUFBSTBCLE1BQU0sbUNBQTRDLE9BQVRFO1FBQ3JEO0lBQ0Y7SUFFQSxNQUFNVSxjQUFzQztRQUMxQyxJQUFJO1lBQ0YsSUFBSUMsY0FBNkIsRUFBRTtZQUNuQyxJQUFJQyxPQUFPO1lBQ1gsTUFBTUMsVUFBVTtZQUVoQixNQUFPLEtBQU07b0JBR01wQjtnQkFGakIsTUFBTUEsT0FBTyxNQUFNLElBQUksQ0FBQ00sV0FBVyxDQUFDLGlCQUFrQ2MsT0FBakJELE1BQUssY0FBb0IsT0FBUkM7Z0JBRXRFLE1BQU1DLFdBQVdyQixFQUFBQSxpQkFBQUEsS0FBS3FCLFFBQVEsY0FBYnJCLHFDQUFBQSxlQUFlc0IsR0FBRyxDQUFDLENBQUNDO29CQUNuQyxnREFBZ0Q7b0JBQ2hELElBQUlKLFNBQVMsS0FBS0QsWUFBWU0sTUFBTSxLQUFLLEdBQUc7d0JBQzFDbkQsUUFBUUMsR0FBRyxDQUFDLDZCQUE2Qm1ELEtBQUtDLFNBQVMsQ0FBQ0gsU0FBUyxNQUFNO29CQUN6RTtvQkFFQSxPQUFPO3dCQUNMSSxZQUFZSixRQUFRSSxVQUFVO3dCQUM5QkMsY0FBY0wsUUFBUUssWUFBWSxJQUFJTCxRQUFRTSxJQUFJLElBQUk7d0JBQ3REQyxhQUFhUCxRQUFRTyxXQUFXLElBQUk7d0JBQ3BDbEIsUUFBUVcsUUFBUVgsTUFBTSxJQUFJO3dCQUMxQm1CLFlBQVlSLFFBQVFRLFVBQVUsSUFBSTt3QkFDbENDLFVBQVVULFFBQVFTLFFBQVEsSUFBSTt3QkFDOUJDLGVBQWVWLFFBQVFVLGFBQWEsSUFBSTt3QkFDeENDLGVBQWVYLFFBQVFXLGFBQWEsSUFBSTt3QkFDeENDLGFBQWFaLFFBQVFZLFdBQVcsSUFBSTt3QkFDcENDLGVBQWViLFFBQVFhLGFBQWEsSUFBSTt3QkFDeENDLFlBQVlDO29CQUNkO2dCQUNGLE9BQU0sRUFBRTtnQkFFUnBCLGNBQWNBLFlBQVlxQixNQUFNLENBQUNsQjtnQkFFakMsaUNBQWlDO2dCQUNqQyxJQUFJQSxTQUFTRyxNQUFNLEdBQUdKLFNBQVM7b0JBQzdCO2dCQUNGO2dCQUVBRDtZQUNGO1lBRUE5QyxRQUFRQyxHQUFHLENBQUMsV0FBOEIsT0FBbkI0QyxZQUFZTSxNQUFNLEVBQUM7WUFDMUMsT0FBT047UUFDVCxFQUFFLE9BQU92QyxPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyw0QkFBNEJBO1lBQzFDLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxNQUFNNkQsK0JBQXVEO1FBQzNELElBQUk7WUFDRm5FLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU0rQyxXQUFXLE1BQU0sSUFBSSxDQUFDSixXQUFXO1lBRXZDLDZDQUE2QztZQUM3QyxNQUFNd0IsNEJBQTRCcEIsU0FBU3FCLE1BQU0sQ0FBQ25CLENBQUFBO2dCQUNoRCxNQUFNb0IsbUJBQW1CcEIsUUFBUWMsVUFBVSxJQUFJZCxRQUFRYyxVQUFVLEdBQUc7Z0JBQ3BFLElBQUlNLGtCQUFrQjtvQkFDcEJ0RSxRQUFRQyxHQUFHLENBQUMsV0FBd0RpRCxPQUE3Q0EsUUFBUUssWUFBWSxFQUFDLDBCQUEyQyxPQUFuQkwsUUFBUWMsVUFBVTtnQkFDeEY7Z0JBQ0EsT0FBT007WUFDVDtZQUVBdEUsUUFBUUMsR0FBRyxDQUFDLFNBQTBDLE9BQWpDbUUsMEJBQTBCakIsTUFBTSxFQUFDO1lBQ3RELE9BQU9IO1FBQ1QsRUFBRSxPQUFPMUMsT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMsZ0RBQWdEQTtZQUM5RCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsTUFBTWlFLHFCQUFvQztRQUN4QyxJQUFJO1lBQ0Z2RSxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNMEIsT0FBTyxNQUFNLElBQUksQ0FBQ00sV0FBVyxDQUFDO1lBRXBDLElBQUlOLEtBQUtxQixRQUFRLElBQUlyQixLQUFLcUIsUUFBUSxDQUFDRyxNQUFNLEdBQUcsR0FBRztnQkFDN0NuRCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTXVFLGdCQUFnQjdDLEtBQUtxQixRQUFRLENBQUMsRUFBRTtnQkFDdEN5QixPQUFPQyxJQUFJLENBQUNGLGVBQWVHLE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQ2pDNUUsUUFBUUMsR0FBRyxDQUFDLEtBQWF1RSxPQUFSSSxLQUFJLE1BQTJCLE9BQXZCSixhQUFhLENBQUNJLElBQUksRUFBQyxNQUE4QixPQUExQixPQUFPSixhQUFhLENBQUNJLElBQUksRUFBQztnQkFDNUU7Z0JBRUEsd0NBQXdDO2dCQUN4QyxJQUFJSixjQUFjSyxjQUFjLEtBQUtaLFdBQVc7b0JBQzlDakUsUUFBUUMsR0FBRyxDQUFDLGlDQUE4RCxPQUE3QnVFLGNBQWNLLGNBQWM7Z0JBQzNFLE9BQU87b0JBQ0w3RSxRQUFRQyxHQUFHLENBQUM7b0JBQ1pELFFBQVFDLEdBQUcsQ0FBQztvQkFDWndFLE9BQU9DLElBQUksQ0FBQ0YsZUFBZUcsT0FBTyxDQUFDQyxDQUFBQTt3QkFDakMsSUFBSUEsSUFBSUUsV0FBVyxHQUFHQyxRQUFRLENBQUMsYUFBYUgsSUFBSUUsV0FBVyxHQUFHQyxRQUFRLENBQUMsWUFBWTs0QkFDakYvRSxRQUFRQyxHQUFHLENBQUMsS0FBYXVFLE9BQVJJLEtBQUksTUFBdUIsT0FBbkJKLGFBQWEsQ0FBQ0ksSUFBSTt3QkFDN0M7b0JBQ0Y7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMNUUsUUFBUUMsR0FBRyxDQUFDO1lBQ2Q7UUFDRixFQUFFLE9BQU9LLE9BQU87WUFDZE4sUUFBUU0sS0FBSyxDQUFDLG1DQUFtQ0E7UUFDbkQ7SUFDRjtJQUVBLE1BQU0wRSwyQkFBbUQ7UUFDdkQsSUFBSTtZQUNGLE1BQU1oQyxXQUFXLE1BQU0sSUFBSSxDQUFDSixXQUFXO1lBRXZDLDBGQUEwRjtZQUMxRixNQUFNcUMsd0JBQXdCLE1BQU1DLFFBQVFDLEdBQUcsQ0FDN0NuQyxTQUFTb0MsS0FBSyxDQUFDLEdBQUcsR0FBR25DLEdBQUcsQ0FBQyxPQUFPQztnQkFDOUIsSUFBSTtvQkFDRixNQUFNbUMsWUFBWSxNQUFNLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNwQyxRQUFRSSxVQUFVO29CQUNuRSxNQUFNaUMsc0JBQXNCRixVQUFVRyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsV0FBYUQsTUFBT0MsQ0FBQUEsU0FBU0MsS0FBSyxJQUFJLElBQUk7b0JBRTdGM0YsUUFBUUMsR0FBRyxDQUFDLFdBQWdDLE9BQXJCaUQsUUFBUUssWUFBWSxFQUFDLGdCQUFjOEIsVUFBVWxDLE1BQU0sRUFBRSxpQkFBaUJvQztvQkFFN0YsT0FBTzt3QkFDTCxHQUFHckMsT0FBTzt3QkFDVmMsWUFBWWQsUUFBUWMsVUFBVSxJQUFJdUIsdUJBQXVCO29CQUMzRDtnQkFDRixFQUFFLE9BQU9qRixPQUFPO29CQUNkTixRQUFRTSxLQUFLLENBQUMsd0NBQTJELE9BQW5CNEMsUUFBUUksVUFBVSxFQUFDLE1BQUloRDtvQkFDN0UsT0FBTzRDO2dCQUNUO1lBQ0Y7WUFHRixrRkFBa0Y7WUFDbEYsT0FBTzttQkFDRitCO21CQUNBakMsU0FBU29DLEtBQUssQ0FBQzthQUNuQjtRQUNILEVBQUUsT0FBTzlFLE9BQU87WUFDZE4sUUFBUU0sS0FBSyxDQUFDLDJDQUEyQ0E7WUFDekQsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLE1BQU1zRiwrQkFBdUQ7UUFDM0QsSUFBSTtZQUNGLE1BQU0sQ0FBQzVDLFVBQVU2QyxTQUFTLEdBQUcsTUFBTVgsUUFBUUMsR0FBRyxDQUFDO2dCQUM3QyxJQUFJLENBQUN2QyxXQUFXO2dCQUNoQixJQUFJLENBQUNrRCxXQUFXO2FBQ2pCO1lBRUQsaUVBQWlFO1lBQ2pFLE1BQU1DLDRCQUE0Qi9DLFNBQVNDLEdBQUcsQ0FBQ0MsQ0FBQUE7Z0JBQzdDLE1BQU04QyxrQkFBa0JILFNBQVN4QixNQUFNLENBQUM0QixDQUFBQSxVQUFXQSxRQUFRM0MsVUFBVSxLQUFLSixRQUFRSSxVQUFVO2dCQUM1RixNQUFNNEMscUJBQXFCRixnQkFBZ0JSLE1BQU0sQ0FBQyxDQUFDQyxLQUFLUSxVQUFZUixNQUFNUSxRQUFRRSxNQUFNLEVBQUU7Z0JBRTFGbkcsUUFBUUMsR0FBRyxDQUFDLFdBQWdDLE9BQXJCaUQsUUFBUUssWUFBWSxFQUFDLGVBQWF5QyxnQkFBZ0I3QyxNQUFNLEVBQUUsaUJBQWlCK0M7Z0JBRWxHLE9BQU87b0JBQ0wsR0FBR2hELE9BQU87b0JBQ1ZjLFlBQVlkLFFBQVFjLFVBQVUsSUFBSWtDLHNCQUFzQjtnQkFDMUQ7WUFDRjtZQUVBLE9BQU9IO1FBQ1QsRUFBRSxPQUFPekYsT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMsZ0RBQWdEQTtZQUM5RCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsTUFBTXdGLGNBQXNDO1FBQzFDLElBQUk7Z0JBRUtuRTtZQURQLE1BQU1BLE9BQU8sTUFBTSxJQUFJLENBQUNNLFdBQVcsQ0FBQztZQUNwQyxPQUFPTixFQUFBQSxpQkFBQUEsS0FBS2tFLFFBQVEsY0FBYmxFLHFDQUFBQSxlQUFlc0IsR0FBRyxDQUFDLENBQUNnRCxVQUFrQjtvQkFDM0NHLFlBQVlILFFBQVFHLFVBQVU7b0JBQzlCOUMsWUFBWTJDLFFBQVEzQyxVQUFVO29CQUM5QitDLGdCQUFnQkosUUFBUUksY0FBYztvQkFDdENDLE1BQU1MLFFBQVFLLElBQUk7b0JBQ2xCSCxRQUFRRixRQUFRTixLQUFLO29CQUNyQnBELFFBQVEwRCxRQUFRMUQsTUFBTTtvQkFDdEJnRSxlQUFlTixRQUFRTSxhQUFhLElBQUk7b0JBQ3hDQyxpQkFBaUJQLFFBQVFPLGVBQWUsSUFBSTtnQkFDOUMsUUFBTyxFQUFFO1FBQ1gsRUFBRSxPQUFPbEcsT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsTUFBTW1HLG1CQUFtQkMsU0FBaUIsRUFBMEI7UUFDbEUsSUFBSTtnQkFFSy9FO1lBRFAsTUFBTUEsT0FBTyxNQUFNLElBQUksQ0FBQ00sV0FBVyxDQUFDLFlBQXNCLE9BQVZ5RSxXQUFVO1lBQzFELE9BQU8vRSxFQUFBQSxpQkFBQUEsS0FBS2tFLFFBQVEsY0FBYmxFLHFDQUFBQSxlQUFlc0IsR0FBRyxDQUFDLENBQUNnRCxVQUFrQjtvQkFDM0NHLFlBQVlILFFBQVFHLFVBQVU7b0JBQzlCOUMsWUFBWTJDLFFBQVEzQyxVQUFVO29CQUM5QitDLGdCQUFnQkosUUFBUUksY0FBYztvQkFDdENDLE1BQU1MLFFBQVFLLElBQUk7b0JBQ2xCSCxRQUFRRixRQUFRTixLQUFLO29CQUNyQnBELFFBQVEwRCxRQUFRMUQsTUFBTTtvQkFDdEJnRSxlQUFlTixRQUFRTSxhQUFhLElBQUk7b0JBQ3hDQyxpQkFBaUJQLFFBQVFPLGVBQWUsSUFBSTtnQkFDOUMsUUFBTyxFQUFFO1FBQ1gsRUFBRSxPQUFPbEcsT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMsb0NBQW9DQTtZQUNsRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsTUFBTXFHLGtCQUFrQkQsU0FBaUIsRUFBZ0I7UUFDdkQsSUFBSTtZQUNGLE1BQU0vRSxPQUFPLE1BQU0sSUFBSSxDQUFDTSxXQUFXLENBQUMsWUFBc0IsT0FBVnlFO1lBQ2hEMUcsUUFBUUMsR0FBRyxDQUFDLFdBQXFCLE9BQVZ5RyxXQUFVLGNBQVl0RCxLQUFLQyxTQUFTLENBQUMxQixNQUFNLE1BQU07WUFDeEUsT0FBT0E7UUFDVCxFQUFFLE9BQU9yQixPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ2pELE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTWdGLG9CQUFvQm9CLFNBQWlCLEVBQWtCO1FBQzNELElBQUk7WUFDRixNQUFNL0UsT0FBTyxNQUFNLElBQUksQ0FBQ00sV0FBVyxDQUFDLFlBQXNCLE9BQVZ5RSxXQUFVO1lBQzFEMUcsUUFBUUMsR0FBRyxDQUFDLFdBQXFCLE9BQVZ5RyxXQUFVLGdCQUFjdEQsS0FBS0MsU0FBUyxDQUFDMUIsTUFBTSxNQUFNO1lBQzFFLE9BQU9BLEtBQUswRCxTQUFTLElBQUksRUFBRTtRQUM3QixFQUFFLE9BQU8vRSxPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25ELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxNQUFNc0csb0JBQW9CRixTQUFpQixFQUFrQjtRQUMzRCxJQUFJO1lBQ0YsTUFBTS9FLE9BQU8sTUFBTSxJQUFJLENBQUNNLFdBQVcsQ0FBQyxZQUFzQixPQUFWeUUsV0FBVTtZQUMxRDFHLFFBQVFDLEdBQUcsQ0FBQyxXQUFxQixPQUFWeUcsV0FBVSxnQkFBY3RELEtBQUtDLFNBQVMsQ0FBQzFCLE1BQU0sTUFBTTtZQUMxRSxPQUFPQSxLQUFLa0YsU0FBUyxJQUFJLEVBQUU7UUFDN0IsRUFBRSxPQUFPdkcsT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsNENBQTRDO0lBQzVDLE1BQU13RyxpQkFBaUJDLFNBQWlCLEVBQUVDLE9BQWUsRUFBZ0I7UUFDdkUsSUFBSTtZQUNGLE1BQU1yRixPQUFPLE1BQU0sSUFBSSxDQUFDTSxXQUFXLENBQUMsbUNBQXdEK0UsT0FBckJELFdBQVUsYUFBbUIsT0FBUkM7WUFDNUZoSCxRQUFRQyxHQUFHLENBQUMsdUJBQXVCbUQsS0FBS0MsU0FBUyxDQUFDMUIsTUFBTSxNQUFNO1lBQzlELE9BQU9BO1FBQ1QsRUFBRSxPQUFPckIsT0FBTztZQUNkTixRQUFRTSxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLHdDQUF3QztJQUN4QyxNQUFNMkcsWUFBWUYsU0FBaUIsRUFBRUMsT0FBZSxFQUFnQjtRQUNsRSxJQUFJO1lBQ0YsTUFBTXJGLE9BQU8sTUFBTSxJQUFJLENBQUNNLFdBQVcsQ0FBQyw4QkFBbUQrRSxPQUFyQkQsV0FBVSxhQUFtQixPQUFSQztZQUN2RmhILFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUJtRCxLQUFLQyxTQUFTLENBQUMxQixNQUFNLE1BQU07WUFDMUQsT0FBT0E7UUFDVCxFQUFFLE9BQU9yQixPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE9BQU87UUFDVDtJQUNGO0lBRUEsa0NBQWtDO0lBQ2xDLE1BQU00RyxnQkFBZ0JaLElBQVksRUFBZ0I7UUFDaEQsSUFBSTtZQUNGLE1BQU0zRSxPQUFPLE1BQU0sSUFBSSxDQUFDTSxXQUFXLENBQUMsNkJBQWtDLE9BQUxxRTtZQUNqRXRHLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJtRCxLQUFLQyxTQUFTLENBQUMxQixNQUFNLE1BQU07WUFDOUQsT0FBT0E7UUFDVCxFQUFFLE9BQU9yQixPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE9BQU87UUFDVDtJQUNGO0lBRUEsc0NBQXNDO0lBQ3RDLE1BQU02RyxxQkFBcUM7UUFDekMsSUFBSTtZQUNGLE1BQU14RixPQUFPLE1BQU0sSUFBSSxDQUFDTSxXQUFXLENBQUM7WUFDcENqQyxRQUFRQyxHQUFHLENBQUMsMkJBQTJCbUQsS0FBS0MsU0FBUyxDQUFDMUIsTUFBTSxNQUFNO1lBQ2xFLE9BQU9BLEtBQUt5RixlQUFlLElBQUksRUFBRTtRQUNuQyxFQUFFLE9BQU85RyxPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25ELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsTUFBTStHLGtCQUFrQk4sU0FBaUIsRUFBRUMsT0FBZSxFQUFrQjtRQUMxRSxJQUFJO1lBQ0YsTUFBTXJGLE9BQU8sTUFBTSxJQUFJLENBQUNNLFdBQVcsQ0FBQyw0QkFBaUQrRSxPQUFyQkQsV0FBVSxhQUFtQixPQUFSQztZQUNyRmhILFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJtRCxLQUFLQyxTQUFTLENBQUMxQixNQUFNLE1BQU07WUFDaEUsT0FBT0EsS0FBSzJGLGNBQWMsSUFBSSxFQUFFO1FBQ2xDLEVBQUUsT0FBT2hILE9BQU87WUFDZE4sUUFBUU0sS0FBSyxDQUFDLG1DQUFtQ0E7WUFDakQsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLG9EQUFvRDtJQUNwRCxNQUFNaUgsb0JBQW9CUixTQUFpQixFQUFFQyxPQUFlLEVBVXpEO1FBQ0QsSUFBSTtnQkFRY1EsaUJBQ0NBLGtCQUlnQkEsNEJBQ01BLDZCQUlaQyx3QkFDSEEsNkJBQ0pBO1lBbkJwQixNQUFNLENBQUNELFFBQVFFLFFBQVFELE9BQU8sR0FBRyxNQUFNdkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNqRCxJQUFJLENBQUMyQixnQkFBZ0IsQ0FBQ0MsV0FBV0M7Z0JBQ2pDLElBQUksQ0FBQ0MsV0FBVyxDQUFDRixXQUFXQztnQkFDNUIsSUFBSSxDQUFDRSxlQUFlLENBQUNGO2FBQ3RCO1lBRUQsK0NBQStDO1lBQy9DLE1BQU1XLFVBQVVILENBQUFBLG1CQUFBQSw4QkFBQUEsa0JBQUFBLE9BQVFHLE9BQU8sY0FBZkgsc0NBQUFBLGdCQUFpQjdCLEtBQUssS0FBSTtZQUMxQyxNQUFNaUMsV0FBV0osQ0FBQUEsbUJBQUFBLDhCQUFBQSxtQkFBQUEsT0FBUUksUUFBUSxjQUFoQkosdUNBQUFBLGlCQUFrQjdCLEtBQUssS0FBSTtZQUM1QyxNQUFNa0MsY0FBY0YsVUFBVUM7WUFFOUIscUZBQXFGO1lBQ3JGLE1BQU1FLFlBQVlELGNBQWVMLENBQUFBLENBQUFBLG1CQUFBQSw4QkFBQUEsNkJBQUFBLE9BQVFPLGtCQUFrQixjQUExQlAsaURBQUFBLDJCQUE0QjdCLEtBQUssS0FBSTtZQUN0RSxNQUFNcUMsa0JBQWtCSCxjQUFlTCxDQUFBQSxDQUFBQSxtQkFBQUEsOEJBQUFBLDhCQUFBQSxPQUFRTyxrQkFBa0IsY0FBMUJQLGtEQUFBQSw0QkFBNEI3QixLQUFLLEtBQUk7WUFFNUUseUJBQXlCO1lBQ3pCLE1BQU1zQyxXQUFXUCxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFRLGFBQWEsS0FBSTtZQUMxQyxNQUFNQyxxQkFBcUJWLENBQUFBLG1CQUFBQSw4QkFBQUEseUJBQUFBLE9BQVFXLGNBQWMsY0FBdEJYLDZDQUFBQSx1QkFBd0JZLG1CQUFtQixLQUFJO1lBQzFFLE1BQU1DLGtCQUFrQmIsQ0FBQUEsbUJBQUFBLDhCQUFBQSw4QkFBQUEsT0FBUWMsbUJBQW1CLGNBQTNCZCxrREFBQUEsNEJBQTZCZSxnQkFBZ0IsS0FBSTtZQUN6RSxNQUFNQyxjQUFjaEIsQ0FBQUEsbUJBQUFBLDhCQUFBQSwwQkFBQUEsT0FBUVcsY0FBYyxjQUF0QlgsOENBQUFBLHdCQUF3QmlCLGFBQWEsS0FBSTtZQUU3RCxPQUFPO2dCQUNMZjtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUU7Z0JBQ0FDO2dCQUNBRTtnQkFDQUc7Z0JBQ0FHO1lBQ0Y7UUFDRixFQUFFLE9BQU9uSSxPQUFPO1lBQ2ROLFFBQVFNLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25ELDBDQUEwQztZQUMxQyxPQUFPO2dCQUNMcUgsU0FBUztnQkFDVEMsVUFBVTtnQkFDVkMsYUFBYTtnQkFDYkMsV0FBVztnQkFDWEUsaUJBQWlCO2dCQUNqQkMsVUFBVTtnQkFDVkUsb0JBQW9CO2dCQUNwQkcsaUJBQWlCO2dCQUNqQkcsYUFBYTtZQUNmO1FBQ0Y7SUFDRjtJQUVBLGlEQUFpRDtJQUNqRCxNQUFNcEksb0JBQW1DO1FBQ3ZDLElBQUksQ0FBQ0ssV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ1QsZUFBZSxHQUFHQyxLQUFLQyxHQUFHLElBQUksNEJBQTRCO1FBQy9ELE1BQU0sSUFBSSxDQUFDSyxjQUFjO0lBQzNCO0lBRUEsaUNBQWlDO0lBQ2pDa0ksaUJBQStFO1FBQzdFLE1BQU12SSxNQUFNRCxLQUFLQyxHQUFHO1FBQ3BCLE9BQU87WUFDTHdJLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQ2xJLFdBQVc7WUFDNUJtSSxXQUFXLElBQUksQ0FBQ2xJLFdBQVcsR0FBR1A7WUFDOUIwSSxXQUFXMUksT0FBTyxJQUFJLENBQUNPLFdBQVc7UUFDcEM7SUFDRjtJQUVBLG9DQUFvQztJQUNwQ29JLHVCQUFxRTtRQUNuRSxNQUFNM0ksTUFBTUQsS0FBS0MsR0FBRztRQUNwQixNQUFNNEksdUJBQXVCNUksTUFBTSxJQUFJLENBQUNGLGVBQWU7UUFDdkQsTUFBTStJLGdCQUFnQm5ILEtBQUtvSCxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMzSSxxQkFBcUIsR0FBR3lJO1FBRS9ELE9BQU87WUFDTEcsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDdEosZ0JBQWdCO1lBQ2pDb0o7UUFDRjtJQUNGO0lBRUEsc0NBQXNDO0lBQ3RDRyxvQkFBMEI7UUFDeEIsSUFBSSxDQUFDeEosaUJBQWlCO0lBQ3hCO0lBRUEscUNBQXFDO0lBQ3JDeUoscUJBQTJCO1FBQ3pCLElBQUksQ0FBQzdJLGdCQUFnQjtJQUN2QjtJQUVBLDRDQUE0QztJQUM1QzhJLFlBS0U7UUFDQSxPQUFPO1lBQ0wsR0FBRyxJQUFJLENBQUNYLGNBQWMsRUFBRTtZQUN4QlksYUFBYSxJQUFJLENBQUNSLG9CQUFvQjtRQUN4QztJQUNGO0lBdmlCQVMsYUFBYzthQVJOOUksY0FBNkI7YUFDN0JDLGNBQXNCO2FBQ3RCRSxpQkFBeUM7YUFDaENELHVCQUF1QixJQUFJLEtBQUssS0FBTSxtQkFBbUI7O2FBQ2xFZixtQkFBMEM7YUFDakNVLHdCQUF3QixLQUFLLEtBQUssS0FBTSxhQUFhOzthQUM5REwsa0JBQTBCLEVBQUcsNkNBQTZDOztRQUdoRixnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDTixpQkFBaUI7SUFDeEI7QUFxaUJGO0FBRU8sTUFBTTZKLGNBQWMsSUFBSTlKLGNBQWM7QUFFN0MsMkRBQTJEO0FBQ3BELE1BQU0rSixnQkFBZ0I7SUFDM0IsSUFBSTtRQUNGMUosUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTXVCLFdBQVcsTUFBTW1JLE1BQU07UUFDN0IsTUFBTUMsU0FBUyxNQUFNcEksU0FBU3FJLElBQUk7UUFFbEMsSUFBSUQsT0FBT0UsT0FBTyxFQUFFO1lBQ2xCOUosUUFBUUMsR0FBRyxDQUFDLGdDQUFnQzJKLE9BQU9HLEtBQUssRUFBRTtZQUMxRCxPQUFPSCxPQUFPakksSUFBSTtRQUNwQixPQUFPO1lBQ0wzQixRQUFRTSxLQUFLLENBQUMsK0JBQStCc0osT0FBT3RKLEtBQUs7WUFDekQsTUFBTSxJQUFJMEIsTUFBTTRILE9BQU90SixLQUFLO1FBQzlCO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2ROLFFBQVFNLEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE1BQU1BO0lBQ1I7QUFDRixFQUFFO0FBRUssTUFBTTBKLGdCQUFnQjtJQUMzQixJQUFJO1FBQ0ZoSyxRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNdUIsV0FBVyxNQUFNbUksTUFBTTtRQUM3QixNQUFNQyxTQUFTLE1BQU1wSSxTQUFTcUksSUFBSTtRQUVsQyxJQUFJRCxPQUFPRSxPQUFPLEVBQUU7WUFDbEI5SixRQUFRQyxHQUFHLENBQUMsZ0NBQWdDMkosT0FBT0csS0FBSyxFQUFFO1lBQzFELE9BQU9ILE9BQU9qSSxJQUFJO1FBQ3BCLE9BQU87WUFDTDNCLFFBQVFNLEtBQUssQ0FBQywrQkFBK0JzSixPQUFPdEosS0FBSztZQUN6RCxNQUFNLElBQUkwQixNQUFNNEgsT0FBT3RKLEtBQUs7UUFDOUI7SUFDRixFQUFFLE9BQU9BLE9BQU87UUFDZE4sUUFBUU0sS0FBSyxDQUFDLG9DQUFvQ0E7UUFDbEQsTUFBTUE7SUFDUjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3pvaG8udHM/ZTcwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBab2hvUHJvamVjdCB7XHJcbiAgcHJvamVjdF9pZDogc3RyaW5nO1xyXG4gIHByb2plY3RfbmFtZTogc3RyaW5nOyAvLyBDaGFuZ2VkIGZyb20gbmFtZSB0byBwcm9qZWN0X25hbWVcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBzdGF0dXM6IHN0cmluZztcclxuICBzdGFydF9kYXRlOiBzdHJpbmc7XHJcbiAgZW5kX2RhdGU/OiBzdHJpbmc7XHJcbiAgYnVkZ2V0X2Ftb3VudD86IG51bWJlcjtcclxuICByYXRlX3Blcl9ob3VyPzogbnVtYmVyO1xyXG4gIGN1c3RvbWVyX2lkOiBzdHJpbmc7XHJcbiAgY3VzdG9tZXJfbmFtZTogc3RyaW5nO1xyXG4gIHNpZ25lZF9mZWU/OiBudW1iZXI7IC8vIEFkZGVkIGZvciBTaWduZWQgRmVlIGZyb20gWm9ob1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFpvaG9JbnZvaWNlIHtcclxuICBpbnZvaWNlX2lkOiBzdHJpbmc7XHJcbiAgcHJvamVjdF9pZDogc3RyaW5nO1xyXG4gIGludm9pY2VfbnVtYmVyOiBzdHJpbmc7XHJcbiAgZGF0ZTogc3RyaW5nO1xyXG4gIGFtb3VudDogbnVtYmVyO1xyXG4gIHN0YXR1czogc3RyaW5nO1xyXG4gIGJpbGxlZF9hbW91bnQ6IG51bWJlcjtcclxuICB1bmJpbGxlZF9hbW91bnQ6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRva2VuUmVzcG9uc2Uge1xyXG4gIGFjY2Vzc190b2tlbjogc3RyaW5nO1xyXG4gIGV4cGlyZXNfaW46IG51bWJlcjtcclxuICBhcGlfZG9tYWluOiBzdHJpbmc7XHJcbiAgdG9rZW5fdHlwZTogc3RyaW5nO1xyXG4gIHJlZnJlc2hfdG9rZW4/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIFpvaG9TZXJ2aWNlIHtcclxuICBwcml2YXRlIGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHRva2VuRXhwaXJ5OiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgcmVmcmVzaFByb21pc2U6IFByb21pc2U8c3RyaW5nPiB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgVE9LRU5fUkVGUkVTSF9CVUZGRVIgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXMgYnVmZmVyXHJcbiAgcHJpdmF0ZSBhdXRvUmVmcmVzaFRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgQVVUT19SRUZSRVNIX0lOVEVSVkFMID0gNDUgKiA2MCAqIDEwMDA7IC8vIDQ1IG1pbnV0ZXNcclxuICBwcml2YXRlIGxhc3RSZWZyZXNoVGltZTogbnVtYmVyID0gMDsgLy8gVHJhY2sgd2hlbiBhdXRvLXJlZnJlc2ggd2FzIGxhc3QgdHJpZ2dlcmVkXHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLy8gU3RhcnQgYXV0b21hdGljIHRva2VuIHJlZnJlc2hcclxuICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N0YXJ0QXV0b1JlZnJlc2goKTogdm9pZCB7XHJcbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXJcclxuICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9SZWZyZXNoVGltZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB1cCBhdXRvbWF0aWMgcmVmcmVzaCBldmVyeSA0NSBtaW51dGVzXHJcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGltZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0F1dG8tcmVmcmVzaGluZyBab2hvIHRva2VuICg0NS1taW51dGUgaW50ZXJ2YWwpLi4uJyk7XHJcbiAgICAgICAgdGhpcy5sYXN0UmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpOyAvLyBUcmFjayB3aGVuIHJlZnJlc2ggd2FzIHRyaWdnZXJlZFxyXG4gICAgICAgIGF3YWl0IHRoaXMuZm9yY2VSZWZyZXNoVG9rZW4oKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXV0by1yZWZyZXNoIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRvLXJlZnJlc2ggZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcy5BVVRPX1JFRlJFU0hfSU5URVJWQUwpO1xyXG5cclxuICAgIC8vIFNldCBpbml0aWFsIHJlZnJlc2ggdGltZVxyXG4gICAgdGhpcy5sYXN0UmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc29sZS5sb2coJ0F1dG9tYXRpYyBab2hvIHRva2VuIHJlZnJlc2ggc3RhcnRlZCAoZXZlcnkgNDUgbWludXRlcyknKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N0b3BBdXRvUmVmcmVzaCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9SZWZyZXNoVGltZXIpO1xyXG4gICAgICB0aGlzLmF1dG9SZWZyZXNoVGltZXIgPSBudWxsO1xyXG4gICAgICBjb25zb2xlLmxvZygnQXV0b21hdGljIFpvaG8gdG9rZW4gcmVmcmVzaCBzdG9wcGVkJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAvLyBDaGVjayBpZiB0b2tlbiBpcyBzdGlsbCB2YWxpZCAod2l0aCBidWZmZXIpXHJcbiAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbiAmJiBEYXRlLm5vdygpIDwgKHRoaXMudG9rZW5FeHBpcnkgLSB0aGlzLlRPS0VOX1JFRlJFU0hfQlVGRkVSKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgYSByZWZyZXNoIGluIHByb2dyZXNzLCB3YWl0IGZvciBpdFxyXG4gICAgaWYgKHRoaXMucmVmcmVzaFByb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaFByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhcnQgYSBuZXcgcmVmcmVzaFxyXG4gICAgdGhpcy5yZWZyZXNoUHJvbWlzZSA9IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMucmVmcmVzaFByb21pc2U7XHJcbiAgICAgIHJldHVybiB0b2tlbjtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMucmVmcmVzaFByb21pc2UgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdSZWZyZXNoaW5nIFpvaG8gYWNjZXNzIHRva2VuLi4uJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgZm9ybSBkYXRhIGZvciB0aGUgcmVxdWVzdFxyXG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgICAgZm9ybURhdGEuYXBwZW5kKCdyZWZyZXNoX3Rva2VuJywgcHJvY2Vzcy5lbnYuWk9IT19SRUZSRVNIX1RPS0VOIHx8ICcnKTtcclxuICAgICAgZm9ybURhdGEuYXBwZW5kKCdjbGllbnRfaWQnLCBwcm9jZXNzLmVudi5aT0hPX0NMSUVOVF9JRCB8fCAnJyk7XHJcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnY2xpZW50X3NlY3JldCcsIHByb2Nlc3MuZW52LlpPSE9fQ0xJRU5UX1NFQ1JFVCB8fCAnJyk7XHJcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZ3JhbnRfdHlwZScsICdyZWZyZXNoX3Rva2VuJyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3Q8VG9rZW5SZXNwb25zZT4oJ2h0dHBzOi8vYWNjb3VudHMuem9oby5jb20vb2F1dGgvdjIvdG9rZW4nLCBmb3JtRGF0YSwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSByZXNwb25zZS5kYXRhLmFjY2Vzc190b2tlbjtcclxuICAgICAgdGhpcy50b2tlbkV4cGlyeSA9IERhdGUubm93KCkgKyAocmVzcG9uc2UuZGF0YS5leHBpcmVzX2luICogMTAwMCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgVG9rZW4gcmVmcmVzaGVkIHN1Y2Nlc3NmdWxseS4gRXhwaXJlcyBpbiAke01hdGgucm91bmQocmVzcG9uc2UuZGF0YS5leHBpcmVzX2luIC8gNjApfSBtaW51dGVzYCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgWm9obyBhY2Nlc3MgdG9rZW46JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdXRoZW50aWNhdGUgd2l0aCBab2hvJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0KGVuZHBvaW50OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgaHR0cHM6Ly93d3cuem9ob2FwaXMuY29tL2Jvb2tzL3YzLyR7ZW5kcG9pbnR9YCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICBvcmdhbml6YXRpb25faWQ6IHByb2Nlc3MuZW52LlpPSE9fT1JHQU5JWkFUSU9OX0lELFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIC8vIElmIHdlIGdldCBhIDQwMSwgdHJ5IHJlZnJlc2hpbmcgdGhlIHRva2VuIG9uY2VcclxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUb2tlbiBleHBpcmVkLCByZWZyZXNoaW5nLi4uJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgdG9rZW4gYW5kIGZvcmNlIGEgcmVmcmVzaFxyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG9rZW5FeHBpcnkgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBuZXdUb2tlbiA9IGF3YWl0IHRoaXMuZm9yY2VSZWZyZXNoVG9rZW4oKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgbmV3IHRva2VuXHJcbiAgICAgICAgICBjb25zdCByZXRyeVJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGBodHRwczovL3d3dy56b2hvYXBpcy5jb20vYm9va3MvdjMvJHtlbmRwb2ludH1gLCB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtuZXdUb2tlbn1gLFxyXG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICAgIG9yZ2FuaXphdGlvbl9pZDogcHJvY2Vzcy5lbnYuWk9IT19PUkdBTklaQVRJT05fSUQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgcmV0cnkgc3VjY2Vzc2Z1bCBhZnRlciB0b2tlbiByZWZyZXNoJyk7XHJcbiAgICAgICAgICByZXR1cm4gcmV0cnlSZXNwb25zZS5kYXRhO1xyXG4gICAgICAgIH0gY2F0Y2ggKHJlZnJlc2hFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlZnJlc2ggdG9rZW4gb3IgcmV0cnkgcmVxdWVzdDonLCByZWZyZXNoRXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBab2hvIEFQSSBhdXRoZW50aWNhdGlvbiBmYWlsZWQgYWZ0ZXIgdG9rZW4gcmVmcmVzaDogJHtlbmRwb2ludH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSBvdGhlciBIVFRQIGVycm9yc1xyXG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFpvaG8gQVBJIGVycm9yICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfSBmb3IgJHtlbmRwb2ludH06YCwgZXJyb3IucmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBab2hvIEFQSSBlcnJvciAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3IucmVzcG9uc2UuZGF0YT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIG1ha2luZyBab2hvIHJlcXVlc3QgdG8gJHtlbmRwb2ludH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBkYXRhIGZyb20gWm9obzogJHtlbmRwb2ludH1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RzKCk6IFByb21pc2U8Wm9ob1Byb2plY3RbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IGFsbFByb2plY3RzOiBab2hvUHJvamVjdFtdID0gW107XHJcbiAgICAgIGxldCBwYWdlID0gMTtcclxuICAgICAgY29uc3QgcGVyUGFnZSA9IDIwMDtcclxuICAgICAgXHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHByb2plY3RzP3BhZ2U9JHtwYWdlfSZwZXJfcGFnZT0ke3BlclBhZ2V9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcHJvamVjdHMgPSBkYXRhLnByb2plY3RzPy5tYXAoKHByb2plY3Q6IGFueSkgPT4ge1xyXG4gICAgICAgICAgLy8gTG9nIHRoZSBmaXJzdCBwcm9qZWN0IHRvIHNlZSBhdmFpbGFibGUgZmllbGRzXHJcbiAgICAgICAgICBpZiAocGFnZSA9PT0gMSAmJiBhbGxQcm9qZWN0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NhbXBsZSBab2hvIHByb2plY3QgZGF0YTonLCBKU09OLnN0cmluZ2lmeShwcm9qZWN0LCBudWxsLCAyKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb2plY3RfaWQ6IHByb2plY3QucHJvamVjdF9pZCxcclxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwcm9qZWN0LnByb2plY3RfbmFtZSB8fCBwcm9qZWN0Lm5hbWUgfHwgJycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwcm9qZWN0LmRlc2NyaXB0aW9uIHx8ICcnLFxyXG4gICAgICAgICAgICBzdGF0dXM6IHByb2plY3Quc3RhdHVzIHx8ICdhY3RpdmUnLFxyXG4gICAgICAgICAgICBzdGFydF9kYXRlOiBwcm9qZWN0LnN0YXJ0X2RhdGUgfHwgJycsXHJcbiAgICAgICAgICAgIGVuZF9kYXRlOiBwcm9qZWN0LmVuZF9kYXRlIHx8ICcnLFxyXG4gICAgICAgICAgICBidWRnZXRfYW1vdW50OiBwcm9qZWN0LmJ1ZGdldF9hbW91bnQgfHwgMCxcclxuICAgICAgICAgICAgcmF0ZV9wZXJfaG91cjogcHJvamVjdC5yYXRlX3Blcl9ob3VyIHx8IDAsXHJcbiAgICAgICAgICAgIGN1c3RvbWVyX2lkOiBwcm9qZWN0LmN1c3RvbWVyX2lkIHx8ICcnLFxyXG4gICAgICAgICAgICBjdXN0b21lcl9uYW1lOiBwcm9qZWN0LmN1c3RvbWVyX25hbWUgfHwgJycsXHJcbiAgICAgICAgICAgIHNpZ25lZF9mZWU6IHVuZGVmaW5lZCwgLy8gUmVtb3ZlIFpvaG8gc2lnbmVkIGZlZSwgb25seSB1c2UgdXNlci1lbnRlcmVkIGRhdGFcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSkgfHwgW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWxsUHJvamVjdHMgPSBhbGxQcm9qZWN0cy5jb25jYXQocHJvamVjdHMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxyXG4gICAgICAgIGlmIChwcm9qZWN0cy5sZW5ndGggPCBwZXJQYWdlKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcGFnZSsrO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hlZCAke2FsbFByb2plY3RzLmxlbmd0aH0gcHJvamVjdHMgZnJvbSBab2hvYCk7XHJcbiAgICAgIHJldHVybiBhbGxQcm9qZWN0cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3RzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdHNXaXRoUmV2ZW51ZUJ1ZGdldCgpOiBQcm9taXNlPFpvaG9Qcm9qZWN0W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwcm9qZWN0cyB3aXRoIHJldmVudWUgYnVkZ2V0IGRhdGEuLi4nKTtcclxuICAgICAgY29uc3QgcHJvamVjdHMgPSBhd2FpdCB0aGlzLmdldFByb2plY3RzKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBMb2cgcHJvamVjdHMgdGhhdCBoYXZlIHJldmVudWVfYnVkZ2V0IGRhdGFcclxuICAgICAgY29uc3QgcHJvamVjdHNXaXRoUmV2ZW51ZUJ1ZGdldCA9IHByb2plY3RzLmZpbHRlcihwcm9qZWN0ID0+IHtcclxuICAgICAgICBjb25zdCBoYXNSZXZlbnVlQnVkZ2V0ID0gcHJvamVjdC5zaWduZWRfZmVlICYmIHByb2plY3Quc2lnbmVkX2ZlZSA+IDA7XHJcbiAgICAgICAgaWYgKGhhc1JldmVudWVCdWRnZXQpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9qZWN0ICR7cHJvamVjdC5wcm9qZWN0X25hbWV9IGhhcyByZXZlbnVlIGJ1ZGdldDogJCR7cHJvamVjdC5zaWduZWRfZmVlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzUmV2ZW51ZUJ1ZGdldDtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtwcm9qZWN0c1dpdGhSZXZlbnVlQnVkZ2V0Lmxlbmd0aH0gcHJvamVjdHMgd2l0aCByZXZlbnVlIGJ1ZGdldCBkYXRhYCk7XHJcbiAgICAgIHJldHVybiBwcm9qZWN0cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3RzIHdpdGggcmV2ZW51ZSBidWRnZXQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWJ1Z1Byb2plY3RGaWVsZHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnRGVidWdnaW5nIFpvaG8gcHJvamVjdCBmaWVsZHMuLi4nKTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJ3Byb2plY3RzP3BhZ2U9MSZwZXJfcGFnZT01Jyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YS5wcm9qZWN0cyAmJiBkYXRhLnByb2plY3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXZhaWxhYmxlIGZpZWxkcyBpbiBab2hvIHByb2plY3QgcmVzcG9uc2U6Jyk7XHJcbiAgICAgICAgY29uc3Qgc2FtcGxlUHJvamVjdCA9IGRhdGEucHJvamVjdHNbMF07XHJcbiAgICAgICAgT2JqZWN0LmtleXMoc2FtcGxlUHJvamVjdCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgJHtrZXl9OiAke3NhbXBsZVByb2plY3Rba2V5XX0gKCR7dHlwZW9mIHNhbXBsZVByb2plY3Rba2V5XX0pYCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgc3BlY2lmaWNhbGx5IGZvciByZXZlbnVlX2J1ZGdldFxyXG4gICAgICAgIGlmIChzYW1wbGVQcm9qZWN0LnJldmVudWVfYnVkZ2V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgcmV2ZW51ZV9idWRnZXQgZmllbGQ6ICR7c2FtcGxlUHJvamVjdC5yZXZlbnVlX2J1ZGdldH1gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KdjCByZXZlbnVlX2J1ZGdldCBmaWVsZCBub3QgZm91bmQgaW4gWm9obyByZXNwb25zZScpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0F2YWlsYWJsZSBidWRnZXQtcmVsYXRlZCBmaWVsZHM6Jyk7XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhzYW1wbGVQcm9qZWN0KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYnVkZ2V0JykgfHwga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3JldmVudWUnKSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICR7a2V5fTogJHtzYW1wbGVQcm9qZWN0W2tleV19YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gcHJvamVjdHMgZm91bmQgaW4gWm9obyByZXNwb25zZScpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWJ1Z2dpbmcgcHJvamVjdCBmaWVsZHM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdHNXaXRoRXN0aW1hdGVzKCk6IFByb21pc2U8Wm9ob1Byb2plY3RbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHJvamVjdHMgPSBhd2FpdCB0aGlzLmdldFByb2plY3RzKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBGb3IgdGhlIGZpcnN0IGZldyBwcm9qZWN0cywgdHJ5IHRvIGdldCBlc3RpbWF0ZXMgdG8gc2VlIGlmIHRoYXQgY29udGFpbnMgdGhlIHNpZ25lZCBmZWVcclxuICAgICAgY29uc3QgcHJvamVjdHNXaXRoRXN0aW1hdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgcHJvamVjdHMuc2xpY2UoMCwgNSkubWFwKGFzeW5jIChwcm9qZWN0KSA9PiB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZXMgPSBhd2FpdCB0aGlzLmdldFByb2plY3RFc3RpbWF0ZXMocHJvamVjdC5wcm9qZWN0X2lkKTtcclxuICAgICAgICAgICAgY29uc3QgdG90YWxFc3RpbWF0ZUFtb3VudCA9IGVzdGltYXRlcy5yZWR1Y2UoKHN1bSwgZXN0aW1hdGUpID0+IHN1bSArIChlc3RpbWF0ZS50b3RhbCB8fCAwKSwgMCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvamVjdCAke3Byb2plY3QucHJvamVjdF9uYW1lfSBlc3RpbWF0ZXM6YCwgZXN0aW1hdGVzLmxlbmd0aCwgJ3RvdGFsIGFtb3VudDonLCB0b3RhbEVzdGltYXRlQW1vdW50KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4ucHJvamVjdCxcclxuICAgICAgICAgICAgICBzaWduZWRfZmVlOiBwcm9qZWN0LnNpZ25lZF9mZWUgfHwgdG90YWxFc3RpbWF0ZUFtb3VudCB8fCAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZXN0aW1hdGVzIGZvciBwcm9qZWN0ICR7cHJvamVjdC5wcm9qZWN0X2lkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXR1cm4gYWxsIHByb2plY3RzLCB3aXRoIHRoZSBmaXJzdCA1IGhhdmluZyB1cGRhdGVkIHNpZ25lZCBmZWVzIGZyb20gZXN0aW1hdGVzXHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgLi4ucHJvamVjdHNXaXRoRXN0aW1hdGVzLFxyXG4gICAgICAgIC4uLnByb2plY3RzLnNsaWNlKDUpXHJcbiAgICAgIF07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0cyB3aXRoIGVzdGltYXRlczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RzV2l0aEludm9pY2VUb3RhbHMoKTogUHJvbWlzZTxab2hvUHJvamVjdFtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBbcHJvamVjdHMsIGludm9pY2VzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICB0aGlzLmdldFByb2plY3RzKCksXHJcbiAgICAgICAgdGhpcy5nZXRJbnZvaWNlcygpLFxyXG4gICAgICBdKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBzaWduZWQgZmVlIGFzIHRvdGFsIG9mIGFsbCBpbnZvaWNlcyBmb3IgZWFjaCBwcm9qZWN0XHJcbiAgICAgIGNvbnN0IHByb2plY3RzV2l0aEludm9pY2VUb3RhbHMgPSBwcm9qZWN0cy5tYXAocHJvamVjdCA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvamVjdEludm9pY2VzID0gaW52b2ljZXMuZmlsdGVyKGludm9pY2UgPT4gaW52b2ljZS5wcm9qZWN0X2lkID09PSBwcm9qZWN0LnByb2plY3RfaWQpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSW52b2ljZUFtb3VudCA9IHByb2plY3RJbnZvaWNlcy5yZWR1Y2UoKHN1bSwgaW52b2ljZSkgPT4gc3VtICsgaW52b2ljZS5hbW91bnQsIDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBQcm9qZWN0ICR7cHJvamVjdC5wcm9qZWN0X25hbWV9IGludm9pY2VzOmAsIHByb2plY3RJbnZvaWNlcy5sZW5ndGgsICd0b3RhbCBhbW91bnQ6JywgdG90YWxJbnZvaWNlQW1vdW50KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4ucHJvamVjdCxcclxuICAgICAgICAgIHNpZ25lZF9mZWU6IHByb2plY3Quc2lnbmVkX2ZlZSB8fCB0b3RhbEludm9pY2VBbW91bnQgfHwgMCxcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBwcm9qZWN0c1dpdGhJbnZvaWNlVG90YWxzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHMgd2l0aCBpbnZvaWNlIHRvdGFsczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEludm9pY2VzKCk6IFByb21pc2U8Wm9ob0ludm9pY2VbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJ2ludm9pY2VzJyk7XHJcbiAgICAgIHJldHVybiBkYXRhLmludm9pY2VzPy5tYXAoKGludm9pY2U6IGFueSkgPT4gKHtcclxuICAgICAgICBpbnZvaWNlX2lkOiBpbnZvaWNlLmludm9pY2VfaWQsXHJcbiAgICAgICAgcHJvamVjdF9pZDogaW52b2ljZS5wcm9qZWN0X2lkLFxyXG4gICAgICAgIGludm9pY2VfbnVtYmVyOiBpbnZvaWNlLmludm9pY2VfbnVtYmVyLFxyXG4gICAgICAgIGRhdGU6IGludm9pY2UuZGF0ZSxcclxuICAgICAgICBhbW91bnQ6IGludm9pY2UudG90YWwsXHJcbiAgICAgICAgc3RhdHVzOiBpbnZvaWNlLnN0YXR1cyxcclxuICAgICAgICBiaWxsZWRfYW1vdW50OiBpbnZvaWNlLmJpbGxlZF9hbW91bnQgfHwgMCxcclxuICAgICAgICB1bmJpbGxlZF9hbW91bnQ6IGludm9pY2UudW5iaWxsZWRfYW1vdW50IHx8IDAsXHJcbiAgICAgIH0pKSB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGludm9pY2VzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdEludm9pY2VzKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTxab2hvSW52b2ljZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcHJvamVjdHMvJHtwcm9qZWN0SWR9L2ludm9pY2VzYCk7XHJcbiAgICAgIHJldHVybiBkYXRhLmludm9pY2VzPy5tYXAoKGludm9pY2U6IGFueSkgPT4gKHtcclxuICAgICAgICBpbnZvaWNlX2lkOiBpbnZvaWNlLmludm9pY2VfaWQsXHJcbiAgICAgICAgcHJvamVjdF9pZDogaW52b2ljZS5wcm9qZWN0X2lkLFxyXG4gICAgICAgIGludm9pY2VfbnVtYmVyOiBpbnZvaWNlLmludm9pY2VfbnVtYmVyLFxyXG4gICAgICAgIGRhdGU6IGludm9pY2UuZGF0ZSxcclxuICAgICAgICBhbW91bnQ6IGludm9pY2UudG90YWwsXHJcbiAgICAgICAgc3RhdHVzOiBpbnZvaWNlLnN0YXR1cyxcclxuICAgICAgICBiaWxsZWRfYW1vdW50OiBpbnZvaWNlLmJpbGxlZF9hbW91bnQgfHwgMCxcclxuICAgICAgICB1bmJpbGxlZF9hbW91bnQ6IGludm9pY2UudW5iaWxsZWRfYW1vdW50IHx8IDAsXHJcbiAgICAgIH0pKSB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3QgaW52b2ljZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0RGV0YWlscyhwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcHJvamVjdHMvJHtwcm9qZWN0SWR9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9qZWN0ICR7cHJvamVjdElkfSBkZXRhaWxzOmAsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0IGRldGFpbHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RFc3RpbWF0ZXMocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcHJvamVjdHMvJHtwcm9qZWN0SWR9L2VzdGltYXRlc2ApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgUHJvamVjdCAke3Byb2plY3RJZH0gZXN0aW1hdGVzOmAsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGEuZXN0aW1hdGVzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdCBlc3RpbWF0ZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0Q29udHJhY3RzKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHByb2plY3RzLyR7cHJvamVjdElkfS9jb250cmFjdHNgKTtcclxuICAgICAgY29uc29sZS5sb2coYFByb2plY3QgJHtwcm9qZWN0SWR9IGNvbnRyYWN0czpgLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhLmNvbnRyYWN0cyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3QgY29udHJhY3RzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTmV3IG1ldGhvZCB0byBnZXQgUHJvZml0ICYgTG9zcyBzdGF0ZW1lbnRcclxuICBhc3luYyBnZXRQcm9maXRBbmRMb3NzKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHJlcG9ydHMvcHJvZml0YW5kbG9zcz9mcm9tX2RhdGU9JHtzdGFydERhdGV9JnRvX2RhdGU9JHtlbmREYXRlfWApO1xyXG4gICAgICBjb25zb2xlLmxvZygnUHJvZml0ICYgTG9zcyBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBQcm9maXQgJiBMb3NzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOZXcgbWV0aG9kIHRvIGdldCBDYXNoIEZsb3cgc3RhdGVtZW50XHJcbiAgYXN5bmMgZ2V0Q2FzaEZsb3coc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcmVwb3J0cy9jYXNoZmxvdz9mcm9tX2RhdGU9JHtzdGFydERhdGV9JnRvX2RhdGU9JHtlbmREYXRlfWApO1xyXG4gICAgICBjb25zb2xlLmxvZygnQ2FzaCBGbG93IGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIENhc2ggRmxvdzonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTmV3IG1ldGhvZCB0byBnZXQgQmFsYW5jZSBTaGVldFxyXG4gIGFzeW5jIGdldEJhbGFuY2VTaGVldChkYXRlOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHJlcG9ydHMvYmFsYW5jZXNoZWV0P2RhdGU9JHtkYXRlfWApO1xyXG4gICAgICBjb25zb2xlLmxvZygnQmFsYW5jZSBTaGVldCBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBCYWxhbmNlIFNoZWV0OicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOZXcgbWV0aG9kIHRvIGdldCBDaGFydCBvZiBBY2NvdW50c1xyXG4gIGFzeW5jIGdldENoYXJ0T2ZBY2NvdW50cygpOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnY2hhcnRvZmFjY291bnRzJyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDaGFydCBvZiBBY2NvdW50cyBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGEuY2hhcnRvZmFjY291bnRzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgQ2hhcnQgb2YgQWNjb3VudHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOZXcgbWV0aG9kIHRvIGdldCBKb3VybmFsIEVudHJpZXMgZm9yIGEgZGF0ZSByYW5nZVxyXG4gIGFzeW5jIGdldEpvdXJuYWxFbnRyaWVzKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgam91cm5hbGVudHJpZXM/ZnJvbV9kYXRlPSR7c3RhcnREYXRlfSZ0b19kYXRlPSR7ZW5kRGF0ZX1gKTtcclxuICAgICAgY29uc29sZS5sb2coJ0pvdXJuYWwgRW50cmllcyBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGEuam91cm5hbGVudHJpZXMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBKb3VybmFsIEVudHJpZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOZXcgbWV0aG9kIHRvIGdldCBjb21wcmVoZW5zaXZlIGZpbmFuY2lhbCBtZXRyaWNzXHJcbiAgYXN5bmMgZ2V0RmluYW5jaWFsTWV0cmljcyhzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogUHJvbWlzZTx7XHJcbiAgICByZXZlbnVlOiBudW1iZXI7XHJcbiAgICBleHBlbnNlczogbnVtYmVyO1xyXG4gICAgZ3Jvc3NQcm9maXQ6IG51bWJlcjtcclxuICAgIG5ldFByb2ZpdDogbnVtYmVyO1xyXG4gICAgb3BlcmF0aW5nSW5jb21lOiBudW1iZXI7XHJcbiAgICBjYXNoRmxvdzogbnVtYmVyO1xyXG4gICAgYWNjb3VudHNSZWNlaXZhYmxlOiBudW1iZXI7XHJcbiAgICBhY2NvdW50c1BheWFibGU6IG51bWJlcjtcclxuICAgIGNhc2hCYWxhbmNlOiBudW1iZXI7XHJcbiAgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgW3BsRGF0YSwgY2ZEYXRhLCBic0RhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHRoaXMuZ2V0UHJvZml0QW5kTG9zcyhzdGFydERhdGUsIGVuZERhdGUpLFxyXG4gICAgICAgIHRoaXMuZ2V0Q2FzaEZsb3coc3RhcnREYXRlLCBlbmREYXRlKSxcclxuICAgICAgICB0aGlzLmdldEJhbGFuY2VTaGVldChlbmREYXRlKVxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgZmluYW5jaWFsIG1ldHJpY3MgZnJvbSB0aGUgcmVzcG9uc2VzXHJcbiAgICAgIGNvbnN0IHJldmVudWUgPSBwbERhdGE/LnJldmVudWU/LnRvdGFsIHx8IDA7XHJcbiAgICAgIGNvbnN0IGV4cGVuc2VzID0gcGxEYXRhPy5leHBlbnNlcz8udG90YWwgfHwgMDtcclxuICAgICAgY29uc3QgZ3Jvc3NQcm9maXQgPSByZXZlbnVlIC0gZXhwZW5zZXM7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDYWxjdWxhdGUgbmV0IHByb2ZpdCAobWF5IG5lZWQgYWRqdXN0bWVudCBiYXNlZCBvbiBhY3R1YWwgWm9obyByZXNwb25zZSBzdHJ1Y3R1cmUpXHJcbiAgICAgIGNvbnN0IG5ldFByb2ZpdCA9IGdyb3NzUHJvZml0IC0gKHBsRGF0YT8ub3BlcmF0aW5nX2V4cGVuc2VzPy50b3RhbCB8fCAwKTtcclxuICAgICAgY29uc3Qgb3BlcmF0aW5nSW5jb21lID0gZ3Jvc3NQcm9maXQgLSAocGxEYXRhPy5vcGVyYXRpbmdfZXhwZW5zZXM/LnRvdGFsIHx8IDApO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBjYXNoIGZsb3cgZGF0YVxyXG4gICAgICBjb25zdCBjYXNoRmxvdyA9IGNmRGF0YT8ubmV0X2Nhc2hfZmxvdyB8fCAwO1xyXG4gICAgICBjb25zdCBhY2NvdW50c1JlY2VpdmFibGUgPSBic0RhdGE/LmN1cnJlbnRfYXNzZXRzPy5hY2NvdW50c19yZWNlaXZhYmxlIHx8IDA7XHJcbiAgICAgIGNvbnN0IGFjY291bnRzUGF5YWJsZSA9IGJzRGF0YT8uY3VycmVudF9saWFiaWxpdGllcz8uYWNjb3VudHNfcGF5YWJsZSB8fCAwO1xyXG4gICAgICBjb25zdCBjYXNoQmFsYW5jZSA9IGJzRGF0YT8uY3VycmVudF9hc3NldHM/LmNhc2hfYW5kX2JhbmsgfHwgMDtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmV2ZW51ZSxcclxuICAgICAgICBleHBlbnNlcyxcclxuICAgICAgICBncm9zc1Byb2ZpdCxcclxuICAgICAgICBuZXRQcm9maXQsXHJcbiAgICAgICAgb3BlcmF0aW5nSW5jb21lLFxyXG4gICAgICAgIGNhc2hGbG93LFxyXG4gICAgICAgIGFjY291bnRzUmVjZWl2YWJsZSxcclxuICAgICAgICBhY2NvdW50c1BheWFibGUsXHJcbiAgICAgICAgY2FzaEJhbGFuY2VcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZpbmFuY2lhbCBtZXRyaWNzOicsIGVycm9yKTtcclxuICAgICAgLy8gUmV0dXJuIGRlZmF1bHQgdmFsdWVzIGlmIEFQSSBjYWxscyBmYWlsXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmV2ZW51ZTogMCxcclxuICAgICAgICBleHBlbnNlczogMCxcclxuICAgICAgICBncm9zc1Byb2ZpdDogMCxcclxuICAgICAgICBuZXRQcm9maXQ6IDAsXHJcbiAgICAgICAgb3BlcmF0aW5nSW5jb21lOiAwLFxyXG4gICAgICAgIGNhc2hGbG93OiAwLFxyXG4gICAgICAgIGFjY291bnRzUmVjZWl2YWJsZTogMCxcclxuICAgICAgICBhY2NvdW50c1BheWFibGU6IDAsXHJcbiAgICAgICAgY2FzaEJhbGFuY2U6IDBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1ldGhvZCB0byBtYW51YWxseSByZWZyZXNoIHRva2VuIChmb3IgdGVzdGluZylcclxuICBhc3luYyBmb3JjZVJlZnJlc2hUb2tlbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xyXG4gICAgdGhpcy50b2tlbkV4cGlyeSA9IDA7XHJcbiAgICB0aGlzLmxhc3RSZWZyZXNoVGltZSA9IERhdGUubm93KCk7IC8vIFRyYWNrIG1hbnVhbCByZWZyZXNoIHRpbWVcclxuICAgIGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0b2tlbiBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xyXG4gIGdldFRva2VuU3RhdHVzKCk6IHsgaGFzVG9rZW46IGJvb2xlYW47IGV4cGlyZXNJbjogbnVtYmVyOyBpc0V4cGlyZWQ6IGJvb2xlYW4gfSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaGFzVG9rZW46ICEhdGhpcy5hY2Nlc3NUb2tlbixcclxuICAgICAgZXhwaXJlc0luOiB0aGlzLnRva2VuRXhwaXJ5IC0gbm93LFxyXG4gICAgICBpc0V4cGlyZWQ6IG5vdyA+PSB0aGlzLnRva2VuRXhwaXJ5LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE1ldGhvZCB0byBnZXQgYXV0by1yZWZyZXNoIHN0YXR1c1xyXG4gIGdldEF1dG9SZWZyZXNoU3RhdHVzKCk6IHsgaXNBY3RpdmU6IGJvb2xlYW47IG5leHRSZWZyZXNoSW46IG51bWJlciB9IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0UmVmcmVzaCA9IG5vdyAtIHRoaXMubGFzdFJlZnJlc2hUaW1lO1xyXG4gICAgY29uc3QgbmV4dFJlZnJlc2hJbiA9IE1hdGgubWF4KDAsIHRoaXMuQVVUT19SRUZSRVNIX0lOVEVSVkFMIC0gdGltZVNpbmNlTGFzdFJlZnJlc2gpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc0FjdGl2ZTogISF0aGlzLmF1dG9SZWZyZXNoVGltZXIsXHJcbiAgICAgIG5leHRSZWZyZXNoSW4sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljIG1ldGhvZCB0byBzdGFydCBhdXRvLXJlZnJlc2hcclxuICBlbmFibGVBdXRvUmVmcmVzaCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYyBtZXRob2QgdG8gc3RvcCBhdXRvLXJlZnJlc2hcclxuICBkaXNhYmxlQXV0b1JlZnJlc2goKTogdm9pZCB7XHJcbiAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYyBtZXRob2QgdG8gZ2V0IGNvbXByZWhlbnNpdmUgc3RhdHVzXHJcbiAgZ2V0U3RhdHVzKCk6IHsgXHJcbiAgICBoYXNUb2tlbjogYm9vbGVhbjsgXHJcbiAgICBleHBpcmVzSW46IG51bWJlcjsgXHJcbiAgICBpc0V4cGlyZWQ6IGJvb2xlYW47XHJcbiAgICBhdXRvUmVmcmVzaDogeyBpc0FjdGl2ZTogYm9vbGVhbjsgbmV4dFJlZnJlc2hJbjogbnVtYmVyIH07XHJcbiAgfSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi50aGlzLmdldFRva2VuU3RhdHVzKCksXHJcbiAgICAgIGF1dG9SZWZyZXNoOiB0aGlzLmdldEF1dG9SZWZyZXNoU3RhdHVzKCksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHpvaG9TZXJ2aWNlID0gbmV3IFpvaG9TZXJ2aWNlKCk7IFxyXG5cclxuLy8gRXhwb3J0IHRoZSBmdW5jdGlvbnMgdGhhdCBhcmUgYmVpbmcgaW1wb3J0ZWQgaW4gcGFnZS50c3hcclxuZXhwb3J0IGNvbnN0IGZldGNoUHJvamVjdHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdDbGllbnQ6IEZldGNoaW5nIHByb2plY3RzIGZyb20gQVBJJyk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Byb2plY3RzJyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICBjb25zb2xlLmxvZygnQ2xpZW50OiBTdWNjZXNzZnVsbHkgZmV0Y2hlZCcsIHJlc3VsdC5jb3VudCwgJ3Byb2plY3RzJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsaWVudDogQVBJIHJldHVybmVkIGVycm9yOicsIHJlc3VsdC5lcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDbGllbnQ6IEVycm9yIGZldGNoaW5nIHByb2plY3RzOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmZXRjaEludm9pY2VzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnQ2xpZW50OiBGZXRjaGluZyBpbnZvaWNlcyBmcm9tIEFQSScpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9pbnZvaWNlcycpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgXHJcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0NsaWVudDogU3VjY2Vzc2Z1bGx5IGZldGNoZWQnLCByZXN1bHQuY291bnQsICdpbnZvaWNlcycpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdDbGllbnQ6IEFQSSByZXR1cm5lZCBlcnJvcjonLCByZXN1bHQuZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQ2xpZW50OiBFcnJvciBmZXRjaGluZyBpbnZvaWNlczonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07ICJdLCJuYW1lcyI6WyJheGlvcyIsIlpvaG9TZXJ2aWNlIiwiX3N0YXJ0QXV0b1JlZnJlc2giLCJhdXRvUmVmcmVzaFRpbWVyIiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiY29uc29sZSIsImxvZyIsImxhc3RSZWZyZXNoVGltZSIsIkRhdGUiLCJub3ciLCJmb3JjZVJlZnJlc2hUb2tlbiIsImVycm9yIiwiQVVUT19SRUZSRVNIX0lOVEVSVkFMIiwiX3N0b3BBdXRvUmVmcmVzaCIsImdldEFjY2Vzc1Rva2VuIiwiYWNjZXNzVG9rZW4iLCJ0b2tlbkV4cGlyeSIsIlRPS0VOX1JFRlJFU0hfQlVGRkVSIiwicmVmcmVzaFByb21pc2UiLCJyZWZyZXNoQWNjZXNzVG9rZW4iLCJ0b2tlbiIsImZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwicHJvY2VzcyIsImVudiIsIlpPSE9fUkVGUkVTSF9UT0tFTiIsIlpPSE9fQ0xJRU5UX0lEIiwiWk9IT19DTElFTlRfU0VDUkVUIiwicmVzcG9uc2UiLCJwb3N0IiwiaGVhZGVycyIsImRhdGEiLCJhY2Nlc3NfdG9rZW4iLCJleHBpcmVzX2luIiwiTWF0aCIsInJvdW5kIiwiRXJyb3IiLCJtYWtlUmVxdWVzdCIsImVuZHBvaW50IiwiZ2V0IiwicGFyYW1zIiwib3JnYW5pemF0aW9uX2lkIiwiWk9IT19PUkdBTklaQVRJT05fSUQiLCJzdGF0dXMiLCJuZXdUb2tlbiIsInJldHJ5UmVzcG9uc2UiLCJyZWZyZXNoRXJyb3IiLCJtZXNzYWdlIiwiZ2V0UHJvamVjdHMiLCJhbGxQcm9qZWN0cyIsInBhZ2UiLCJwZXJQYWdlIiwicHJvamVjdHMiLCJtYXAiLCJwcm9qZWN0IiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsInByb2plY3RfaWQiLCJwcm9qZWN0X25hbWUiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJidWRnZXRfYW1vdW50IiwicmF0ZV9wZXJfaG91ciIsImN1c3RvbWVyX2lkIiwiY3VzdG9tZXJfbmFtZSIsInNpZ25lZF9mZWUiLCJ1bmRlZmluZWQiLCJjb25jYXQiLCJnZXRQcm9qZWN0c1dpdGhSZXZlbnVlQnVkZ2V0IiwicHJvamVjdHNXaXRoUmV2ZW51ZUJ1ZGdldCIsImZpbHRlciIsImhhc1JldmVudWVCdWRnZXQiLCJkZWJ1Z1Byb2plY3RGaWVsZHMiLCJzYW1wbGVQcm9qZWN0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJyZXZlbnVlX2J1ZGdldCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJnZXRQcm9qZWN0c1dpdGhFc3RpbWF0ZXMiLCJwcm9qZWN0c1dpdGhFc3RpbWF0ZXMiLCJQcm9taXNlIiwiYWxsIiwic2xpY2UiLCJlc3RpbWF0ZXMiLCJnZXRQcm9qZWN0RXN0aW1hdGVzIiwidG90YWxFc3RpbWF0ZUFtb3VudCIsInJlZHVjZSIsInN1bSIsImVzdGltYXRlIiwidG90YWwiLCJnZXRQcm9qZWN0c1dpdGhJbnZvaWNlVG90YWxzIiwiaW52b2ljZXMiLCJnZXRJbnZvaWNlcyIsInByb2plY3RzV2l0aEludm9pY2VUb3RhbHMiLCJwcm9qZWN0SW52b2ljZXMiLCJpbnZvaWNlIiwidG90YWxJbnZvaWNlQW1vdW50IiwiYW1vdW50IiwiaW52b2ljZV9pZCIsImludm9pY2VfbnVtYmVyIiwiZGF0ZSIsImJpbGxlZF9hbW91bnQiLCJ1bmJpbGxlZF9hbW91bnQiLCJnZXRQcm9qZWN0SW52b2ljZXMiLCJwcm9qZWN0SWQiLCJnZXRQcm9qZWN0RGV0YWlscyIsImdldFByb2plY3RDb250cmFjdHMiLCJjb250cmFjdHMiLCJnZXRQcm9maXRBbmRMb3NzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImdldENhc2hGbG93IiwiZ2V0QmFsYW5jZVNoZWV0IiwiZ2V0Q2hhcnRPZkFjY291bnRzIiwiY2hhcnRvZmFjY291bnRzIiwiZ2V0Sm91cm5hbEVudHJpZXMiLCJqb3VybmFsZW50cmllcyIsImdldEZpbmFuY2lhbE1ldHJpY3MiLCJwbERhdGEiLCJic0RhdGEiLCJjZkRhdGEiLCJyZXZlbnVlIiwiZXhwZW5zZXMiLCJncm9zc1Byb2ZpdCIsIm5ldFByb2ZpdCIsIm9wZXJhdGluZ19leHBlbnNlcyIsIm9wZXJhdGluZ0luY29tZSIsImNhc2hGbG93IiwibmV0X2Nhc2hfZmxvdyIsImFjY291bnRzUmVjZWl2YWJsZSIsImN1cnJlbnRfYXNzZXRzIiwiYWNjb3VudHNfcmVjZWl2YWJsZSIsImFjY291bnRzUGF5YWJsZSIsImN1cnJlbnRfbGlhYmlsaXRpZXMiLCJhY2NvdW50c19wYXlhYmxlIiwiY2FzaEJhbGFuY2UiLCJjYXNoX2FuZF9iYW5rIiwiZ2V0VG9rZW5TdGF0dXMiLCJoYXNUb2tlbiIsImV4cGlyZXNJbiIsImlzRXhwaXJlZCIsImdldEF1dG9SZWZyZXNoU3RhdHVzIiwidGltZVNpbmNlTGFzdFJlZnJlc2giLCJuZXh0UmVmcmVzaEluIiwibWF4IiwiaXNBY3RpdmUiLCJlbmFibGVBdXRvUmVmcmVzaCIsImRpc2FibGVBdXRvUmVmcmVzaCIsImdldFN0YXR1cyIsImF1dG9SZWZyZXNoIiwiY29uc3RydWN0b3IiLCJ6b2hvU2VydmljZSIsImZldGNoUHJvamVjdHMiLCJmZXRjaCIsInJlc3VsdCIsImpzb24iLCJzdWNjZXNzIiwiY291bnQiLCJmZXRjaEludm9pY2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/zoho.ts\n"));

/***/ })

});