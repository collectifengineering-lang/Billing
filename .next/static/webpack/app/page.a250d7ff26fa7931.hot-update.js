"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/zoho.ts":
/*!*********************!*\
  !*** ./lib/zoho.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchInvoices: function() { return /* binding */ fetchInvoices; },\n/* harmony export */   fetchProjects: function() { return /* binding */ fetchProjects; },\n/* harmony export */   zohoService: function() { return /* binding */ zohoService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nclass ZohoService {\n    _startAutoRefresh() {\n        // Clear any existing timer\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n        }\n        // Set up automatic refresh every 45 minutes\n        this.autoRefreshTimer = setInterval(async ()=>{\n            try {\n                console.log(\"Auto-refreshing Zoho token (45-minute interval)...\");\n                this.lastRefreshTime = Date.now(); // Track when refresh was triggered\n                await this.forceRefreshToken();\n                console.log(\"Auto-refresh completed successfully\");\n            } catch (error) {\n                console.error(\"Auto-refresh failed:\", error);\n            }\n        }, this.AUTO_REFRESH_INTERVAL);\n        // Set initial refresh time\n        this.lastRefreshTime = Date.now();\n        console.log(\"Automatic Zoho token refresh started (every 45 minutes)\");\n    }\n    _stopAutoRefresh() {\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n            this.autoRefreshTimer = null;\n            console.log(\"Automatic Zoho token refresh stopped\");\n        }\n    }\n    async getAccessToken() {\n        // Check if token is still valid (with buffer)\n        if (this.accessToken && Date.now() < this.tokenExpiry - this.TOKEN_REFRESH_BUFFER) {\n            return this.accessToken;\n        }\n        // If there's already a refresh in progress, wait for it\n        if (this.refreshPromise) {\n            return this.refreshPromise;\n        }\n        // Start a new refresh\n        this.refreshPromise = this.refreshAccessToken();\n        try {\n            const token = await this.refreshPromise;\n            return token;\n        } finally{\n            this.refreshPromise = null;\n        }\n    }\n    async refreshAccessToken() {\n        try {\n            console.log(\"Refreshing Zoho access token...\");\n            // Create form data for the request\n            const formData = new URLSearchParams();\n            formData.append(\"refresh_token\", \"1000.4bf26c4881dfba83aae32546453d662d.a9353e91362a18c457b5cbec86b10ed2\" || 0);\n            formData.append(\"client_id\", \"1000.8RL8WMTDXS0WIP2EJF2XUS6NDSLQEP\" || 0);\n            formData.append(\"client_secret\", \"8a7ee3c04f0a0d860dd215c4449deab9bf15d1d00b\" || 0);\n            formData.append(\"grant_type\", \"refresh_token\");\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"https://accounts.zoho.com/oauth/v2/token\", formData, {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n            this.accessToken = response.data.access_token;\n            this.tokenExpiry = Date.now() + response.data.expires_in * 1000;\n            console.log(\"Token refreshed successfully. Expires in \".concat(Math.round(response.data.expires_in / 60), \" minutes\"));\n            return this.accessToken;\n        } catch (error) {\n            console.error(\"Error refreshing Zoho access token:\", error);\n            throw new Error(\"Failed to authenticate with Zoho\");\n        }\n    }\n    async makeRequest(endpoint) {\n        try {\n            // Apply rate limiting\n            await this.applyRateLimit();\n            const token = await this.getAccessToken();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://www.zohoapis.com/books/v3/\".concat(endpoint), {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(token),\n                    \"Content-Type\": \"application/json\"\n                },\n                params: {\n                    organization_id: \"652094923\"\n                },\n                timeout: 30000\n            });\n            // Reset retry count on success\n            this.retryCount = 0;\n            this.requestCount++;\n            this.lastRequestTime = Date.now();\n            return response.data;\n        } catch (error) {\n            var _error_response, _error_response_data, _error_response1, _error_response_data_error_description, _error_response_data1, _error_response2, _error_response3, _error_response4;\n            // Handle rate limiting (400 with specific error message)\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 400 && ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.error) === \"Access Denied\" && ((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : (_error_response_data1 = _error_response2.data) === null || _error_response_data1 === void 0 ? void 0 : (_error_response_data_error_description = _error_response_data1.error_description) === null || _error_response_data_error_description === void 0 ? void 0 : _error_response_data_error_description.includes(\"too many requests\"))) {\n                console.log(\"Zoho rate limit hit, implementing exponential backoff...\");\n                await this.handleRateLimit();\n                // Retry the request after backoff\n                if (this.retryCount < this.MAX_RETRIES) {\n                    this.retryCount++;\n                    console.log(\"Retrying request after rate limit backoff (attempt \".concat(this.retryCount, \")\"));\n                    return this.makeRequest(endpoint);\n                } else {\n                    throw new Error(\"Zoho API rate limit exceeded after maximum retries. Please try again later.\");\n                }\n            }\n            // If we get a 401, try refreshing the token once\n            if (((_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status) === 401) {\n                console.log(\"Token expired, refreshing...\");\n                // Clear the current token and force a refresh\n                this.accessToken = null;\n                this.tokenExpiry = 0;\n                try {\n                    const newToken = await this.forceRefreshToken();\n                    // Retry the request with the new token\n                    const retryResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://www.zohoapis.com/books/v3/\".concat(endpoint), {\n                        headers: {\n                            \"Authorization\": \"Bearer \".concat(newToken),\n                            \"Content-Type\": \"application/json\"\n                        },\n                        params: {\n                            organization_id: \"652094923\"\n                        },\n                        timeout: 30000\n                    });\n                    console.log(\"Request retry successful after token refresh\");\n                    return retryResponse.data;\n                } catch (refreshError) {\n                    console.error(\"Failed to refresh token or retry request:\", refreshError);\n                    throw new Error(\"Zoho API authentication failed after token refresh: \".concat(endpoint));\n                }\n            }\n            // Handle other HTTP errors\n            if ((_error_response4 = error.response) === null || _error_response4 === void 0 ? void 0 : _error_response4.status) {\n                var _error_response_data2;\n                console.error(\"Zoho API error \".concat(error.response.status, \" for \").concat(endpoint, \":\"), error.response.data);\n                // Provide more specific error messages\n                if (error.response.status === 403) {\n                    throw new Error(\"Zoho API access forbidden - check your organization ID and permissions\");\n                } else if (error.response.status === 429) {\n                    throw new Error(\"Zoho API rate limit exceeded - please try again later\");\n                } else if (error.response.status >= 500) {\n                    throw new Error(\"Zoho API server error - please try again later\");\n                }\n                throw new Error(\"Zoho API error \".concat(error.response.status, \": \").concat(((_error_response_data2 = error.response.data) === null || _error_response_data2 === void 0 ? void 0 : _error_response_data2.message) || \"Unknown error\"));\n            }\n            console.error(\"Error making Zoho request to \".concat(endpoint, \":\"), error);\n            throw new Error(\"Failed to fetch data from Zoho: \".concat(endpoint));\n        }\n    }\n    async applyRateLimit() {\n        const now = Date.now();\n        // Check if we need to wait between requests\n        if (this.lastRequestTime > 0) {\n            const timeSinceLastRequest = now - this.lastRequestTime;\n            if (timeSinceLastRequest < this.MIN_REQUEST_INTERVAL) {\n                const waitTime = this.MIN_REQUEST_INTERVAL - timeSinceLastRequest;\n                console.log(\"Rate limiting: waiting \".concat(waitTime, \"ms before next request\"));\n                await new Promise((resolve)=>setTimeout(resolve, waitTime));\n            }\n        }\n        // Check if we've exceeded the per-minute limit\n        if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n            const timeSinceFirstRequest = now - this.lastRequestTime;\n            if (timeSinceFirstRequest < 60000) {\n                const waitTime = 60000 - timeSinceFirstRequest;\n                console.log(\"Rate limiting: exceeded \".concat(this.MAX_REQUESTS_PER_MINUTE, \" requests per minute, waiting \").concat(waitTime, \"ms\"));\n                await new Promise((resolve)=>setTimeout(resolve, waitTime));\n                this.requestCount = 0;\n            } else {\n                // Reset counter if more than 1 minute has passed\n                this.requestCount = 0;\n            }\n        }\n    }\n    async handleRateLimit() {\n        const delay = this.BASE_DELAY * Math.pow(2, this.retryCount);\n        console.log(\"Rate limit backoff: waiting \".concat(delay, \"ms before retry\"));\n        await new Promise((resolve)=>setTimeout(resolve, delay));\n        // Reset request counters to allow fresh start\n        this.requestCount = 0;\n        this.lastRequestTime = 0;\n    }\n    async getProjects() {\n        try {\n            let allProjects = [];\n            let page = 1;\n            const perPage = 200;\n            while(true){\n                var _data_projects;\n                const data = await this.makeRequest(\"projects?page=\".concat(page, \"&per_page=\").concat(perPage));\n                const projects = ((_data_projects = data.projects) === null || _data_projects === void 0 ? void 0 : _data_projects.map((project)=>{\n                    // Log the first project to see available fields\n                    if (page === 1 && allProjects.length === 0) {\n                        console.log(\"Sample Zoho project data:\", JSON.stringify(project, null, 2));\n                    }\n                    return {\n                        project_id: project.project_id,\n                        project_name: project.project_name || project.name || \"\",\n                        description: project.description || \"\",\n                        status: project.status || \"active\",\n                        start_date: project.start_date || \"\",\n                        end_date: project.end_date || \"\",\n                        budget_amount: project.budget_amount || 0,\n                        rate_per_hour: project.rate_per_hour || 0,\n                        customer_id: project.customer_id || \"\",\n                        customer_name: project.customer_name || \"\",\n                        signed_fee: undefined\n                    };\n                })) || [];\n                allProjects = allProjects.concat(projects);\n                // Check if we've reached the end\n                if (projects.length < perPage) {\n                    break;\n                }\n                page++;\n            }\n            console.log(\"Fetched \".concat(allProjects.length, \" projects from Zoho\"));\n            return allProjects;\n        } catch (error) {\n            console.error(\"Error fetching projects:\", error);\n            return [];\n        }\n    }\n    async getProjectsWithRevenueBudget() {\n        try {\n            console.log(\"Fetching projects with revenue budget data...\");\n            const projects = await this.getProjects();\n            // Log projects that have revenue_budget data\n            const projectsWithRevenueBudget = projects.filter((project)=>{\n                const hasRevenueBudget = project.signed_fee && project.signed_fee > 0;\n                if (hasRevenueBudget) {\n                    console.log(\"Project \".concat(project.project_name, \" has revenue budget: $\").concat(project.signed_fee));\n                }\n                return hasRevenueBudget;\n            });\n            console.log(\"Found \".concat(projectsWithRevenueBudget.length, \" projects with revenue budget data\"));\n            return projects;\n        } catch (error) {\n            console.error(\"Error fetching projects with revenue budget:\", error);\n            return [];\n        }\n    }\n    async debugProjectFields() {\n        try {\n            console.log(\"Debugging Zoho project fields...\");\n            const data = await this.makeRequest(\"projects?page=1&per_page=5\");\n            if (data.projects && data.projects.length > 0) {\n                console.log(\"Available fields in Zoho project response:\");\n                const sampleProject = data.projects[0];\n                Object.keys(sampleProject).forEach((key)=>{\n                    console.log(\"  \".concat(key, \": \").concat(sampleProject[key], \" (\").concat(typeof sampleProject[key], \")\"));\n                });\n                // Check specifically for revenue_budget\n                if (sampleProject.revenue_budget !== undefined) {\n                    console.log(\"✅ Found revenue_budget field: \".concat(sampleProject.revenue_budget));\n                } else {\n                    console.log(\"❌ revenue_budget field not found in Zoho response\");\n                    console.log(\"Available budget-related fields:\");\n                    Object.keys(sampleProject).forEach((key)=>{\n                        if (key.toLowerCase().includes(\"budget\") || key.toLowerCase().includes(\"revenue\")) {\n                            console.log(\"  \".concat(key, \": \").concat(sampleProject[key]));\n                        }\n                    });\n                }\n            } else {\n                console.log(\"No projects found in Zoho response\");\n            }\n        } catch (error) {\n            console.error(\"Error debugging project fields:\", error);\n        }\n    }\n    async getProjectsWithEstimates() {\n        try {\n            const projects = await this.getProjects();\n            // For the first few projects, try to get estimates to see if that contains the signed fee\n            const projectsWithEstimates = await Promise.all(projects.slice(0, 5).map(async (project)=>{\n                try {\n                    const estimates = await this.getProjectEstimates(project.project_id);\n                    const totalEstimateAmount = estimates.reduce((sum, estimate)=>sum + (estimate.total || 0), 0);\n                    console.log(\"Project \".concat(project.project_name, \" estimates:\"), estimates.length, \"total amount:\", totalEstimateAmount);\n                    return {\n                        ...project,\n                        signed_fee: project.signed_fee || totalEstimateAmount || 0\n                    };\n                } catch (error) {\n                    console.error(\"Error fetching estimates for project \".concat(project.project_id, \":\"), error);\n                    return project;\n                }\n            }));\n            // Return all projects, with the first 5 having updated signed fees from estimates\n            return [\n                ...projectsWithEstimates,\n                ...projects.slice(5)\n            ];\n        } catch (error) {\n            console.error(\"Error fetching projects with estimates:\", error);\n            return [];\n        }\n    }\n    async getProjectsWithInvoiceTotals() {\n        try {\n            const [projects, invoices] = await Promise.all([\n                this.getProjects(),\n                this.getInvoices()\n            ]);\n            // Calculate signed fee as total of all invoices for each project\n            const projectsWithInvoiceTotals = projects.map((project)=>{\n                const projectInvoices = invoices.filter((invoice)=>invoice.project_id === project.project_id);\n                const totalInvoiceAmount = projectInvoices.reduce((sum, invoice)=>sum + invoice.amount, 0);\n                console.log(\"Project \".concat(project.project_name, \" invoices:\"), projectInvoices.length, \"total amount:\", totalInvoiceAmount);\n                return {\n                    ...project,\n                    signed_fee: project.signed_fee || totalInvoiceAmount || 0\n                };\n            });\n            return projectsWithInvoiceTotals;\n        } catch (error) {\n            console.error(\"Error fetching projects with invoice totals:\", error);\n            return [];\n        }\n    }\n    async getInvoices() {\n        try {\n            var _data_invoices;\n            const data = await this.makeRequest(\"invoices\");\n            return ((_data_invoices = data.invoices) === null || _data_invoices === void 0 ? void 0 : _data_invoices.map((invoice)=>({\n                    invoice_id: invoice.invoice_id,\n                    project_id: invoice.project_id,\n                    invoice_number: invoice.invoice_number,\n                    date: invoice.date,\n                    amount: invoice.total,\n                    status: invoice.status,\n                    billed_amount: invoice.billed_amount || 0,\n                    unbilled_amount: invoice.unbilled_amount || 0\n                }))) || [];\n        } catch (error) {\n            console.error(\"Error fetching invoices:\", error);\n            return [];\n        }\n    }\n    async getProjectInvoices(projectId) {\n        try {\n            var _data_invoices;\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/invoices\"));\n            return ((_data_invoices = data.invoices) === null || _data_invoices === void 0 ? void 0 : _data_invoices.map((invoice)=>({\n                    invoice_id: invoice.invoice_id,\n                    project_id: invoice.project_id,\n                    invoice_number: invoice.invoice_number,\n                    date: invoice.date,\n                    amount: invoice.total,\n                    status: invoice.status,\n                    billed_amount: invoice.billed_amount || 0,\n                    unbilled_amount: invoice.unbilled_amount || 0\n                }))) || [];\n        } catch (error) {\n            console.error(\"Error fetching project invoices:\", error);\n            return [];\n        }\n    }\n    async getProjectDetails(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId));\n            console.log(\"Project \".concat(projectId, \" details:\"), JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching project details:\", error);\n            return null;\n        }\n    }\n    async getProjectEstimates(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/estimates\"));\n            console.log(\"Project \".concat(projectId, \" estimates:\"), JSON.stringify(data, null, 2));\n            return data.estimates || [];\n        } catch (error) {\n            console.error(\"Error fetching project estimates:\", error);\n            return [];\n        }\n    }\n    async getProjectContracts(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/contracts\"));\n            console.log(\"Project \".concat(projectId, \" contracts:\"), JSON.stringify(data, null, 2));\n            return data.contracts || [];\n        } catch (error) {\n            console.error(\"Error fetching project contracts:\", error);\n            return [];\n        }\n    }\n    // New method to get Profit & Loss statement\n    async getProfitAndLoss(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"reports/profitandloss?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Profit & Loss data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Profit & Loss:\", error);\n            return null;\n        }\n    }\n    // New method to get Cash Flow statement\n    async getCashFlow(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"reports/cashflow?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Cash Flow data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Cash Flow:\", error);\n            return null;\n        }\n    }\n    // New method to get Balance Sheet\n    async getBalanceSheet(date) {\n        try {\n            const data = await this.makeRequest(\"reports/balancesheet?date=\".concat(date));\n            console.log(\"Balance Sheet data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Balance Sheet:\", error);\n            return null;\n        }\n    }\n    // New method to get Chart of Accounts\n    async getChartOfAccounts() {\n        try {\n            const data = await this.makeRequest(\"chartofaccounts\");\n            console.log(\"Chart of Accounts data:\", JSON.stringify(data, null, 2));\n            return data.chartofaccounts || [];\n        } catch (error) {\n            console.error(\"Error fetching Chart of Accounts:\", error);\n            return [];\n        }\n    }\n    // New method to get Journal Entries for a date range\n    async getJournalEntries(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"journalentries?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Journal Entries data:\", JSON.stringify(data, null, 2));\n            return data.journalentries || [];\n        } catch (error) {\n            console.error(\"Error fetching Journal Entries:\", error);\n            return [];\n        }\n    }\n    // New method to get comprehensive financial metrics\n    async getFinancialMetrics(startDate, endDate) {\n        try {\n            var _plData_revenue, _plData_expenses, _plData_operating_expenses, _plData_operating_expenses1, _bsData_current_assets, _bsData_current_liabilities, _bsData_current_assets1;\n            const [plData, cfData, bsData] = await Promise.all([\n                this.getProfitAndLoss(startDate, endDate),\n                this.getCashFlow(startDate, endDate),\n                this.getBalanceSheet(endDate)\n            ]);\n            // Extract financial metrics from the responses\n            const revenue = (plData === null || plData === void 0 ? void 0 : (_plData_revenue = plData.revenue) === null || _plData_revenue === void 0 ? void 0 : _plData_revenue.total) || 0;\n            const expenses = (plData === null || plData === void 0 ? void 0 : (_plData_expenses = plData.expenses) === null || _plData_expenses === void 0 ? void 0 : _plData_expenses.total) || 0;\n            const grossProfit = revenue - expenses;\n            // Calculate net profit (may need adjustment based on actual Zoho response structure)\n            const netProfit = grossProfit - ((plData === null || plData === void 0 ? void 0 : (_plData_operating_expenses = plData.operating_expenses) === null || _plData_operating_expenses === void 0 ? void 0 : _plData_operating_expenses.total) || 0);\n            const operatingIncome = grossProfit - ((plData === null || plData === void 0 ? void 0 : (_plData_operating_expenses1 = plData.operating_expenses) === null || _plData_operating_expenses1 === void 0 ? void 0 : _plData_operating_expenses1.total) || 0);\n            // Extract cash flow data\n            const cashFlow = (cfData === null || cfData === void 0 ? void 0 : cfData.net_cash_flow) || 0;\n            const accountsReceivable = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_assets = bsData.current_assets) === null || _bsData_current_assets === void 0 ? void 0 : _bsData_current_assets.accounts_receivable) || 0;\n            const accountsPayable = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_liabilities = bsData.current_liabilities) === null || _bsData_current_liabilities === void 0 ? void 0 : _bsData_current_liabilities.accounts_payable) || 0;\n            const cashBalance = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_assets1 = bsData.current_assets) === null || _bsData_current_assets1 === void 0 ? void 0 : _bsData_current_assets1.cash_and_bank) || 0;\n            return {\n                revenue,\n                expenses,\n                grossProfit,\n                netProfit,\n                operatingIncome,\n                cashFlow,\n                accountsReceivable,\n                accountsPayable,\n                cashBalance\n            };\n        } catch (error) {\n            console.error(\"Error fetching financial metrics:\", error);\n            // Return default values if API calls fail\n            return {\n                revenue: 0,\n                expenses: 0,\n                grossProfit: 0,\n                netProfit: 0,\n                operatingIncome: 0,\n                cashFlow: 0,\n                accountsReceivable: 0,\n                accountsPayable: 0,\n                cashBalance: 0\n            };\n        }\n    }\n    // Method to manually refresh token (for testing)\n    async forceRefreshToken() {\n        this.accessToken = null;\n        this.tokenExpiry = 0;\n        this.lastRefreshTime = Date.now(); // Track manual refresh time\n        await this.getAccessToken();\n    }\n    // Get token status for debugging\n    getTokenStatus() {\n        const now = Date.now();\n        return {\n            hasToken: !!this.accessToken,\n            expiresIn: this.tokenExpiry - now,\n            isExpired: now >= this.tokenExpiry\n        };\n    }\n    // Method to get auto-refresh status\n    getAutoRefreshStatus() {\n        const now = Date.now();\n        const timeSinceLastRefresh = now - this.lastRefreshTime;\n        const nextRefreshIn = Math.max(0, this.AUTO_REFRESH_INTERVAL - timeSinceLastRefresh);\n        return {\n            isActive: !!this.autoRefreshTimer,\n            nextRefreshIn\n        };\n    }\n    // Public method to start auto-refresh\n    enableAutoRefresh() {\n        this._startAutoRefresh();\n    }\n    // Public method to stop auto-refresh\n    disableAutoRefresh() {\n        this._stopAutoRefresh();\n    }\n    // Public method to get comprehensive status\n    getStatus() {\n        return {\n            ...this.getTokenStatus(),\n            autoRefresh: this.getAutoRefreshStatus()\n        };\n    }\n    constructor(){\n        this.accessToken = null;\n        this.tokenExpiry = 0;\n        this.refreshPromise = null;\n        this.TOKEN_REFRESH_BUFFER = 5 * 60 * 1000 // 5 minutes buffer\n        ;\n        this.autoRefreshTimer = null;\n        this.AUTO_REFRESH_INTERVAL = 45 * 60 * 1000 // 45 minutes\n        ;\n        this.lastRefreshTime = 0 // Track when auto-refresh was last triggered\n        ;\n        // Rate limiting properties\n        this.requestCount = 0;\n        this.lastRequestTime = 0;\n        this.MAX_REQUESTS_PER_MINUTE = 30 // Conservative limit\n        ;\n        this.MIN_REQUEST_INTERVAL = 2000 // 2 seconds between requests\n        ;\n        this.retryCount = 0;\n        this.MAX_RETRIES = 3;\n        this.BASE_DELAY = 1000 // 1 second base delay for exponential backoff\n        ;\n        // Start automatic token refresh\n        this._startAutoRefresh();\n    }\n}\nconst zohoService = new ZohoService();\n// Export the functions that are being imported in page.tsx\nconst fetchProjects = async ()=>{\n    try {\n        console.log(\"Client: Fetching projects from API\");\n        const response = await fetch(\"/api/projects\");\n        const result = await response.json();\n        if (result.success) {\n            console.log(\"Client: Successfully fetched\", result.count, \"projects\");\n            return result.data;\n        } else {\n            console.error(\"Client: API returned error:\", result.error);\n            throw new Error(result.error);\n        }\n    } catch (error) {\n        console.error(\"Client: Error fetching projects:\", error);\n        throw error;\n    }\n};\nconst fetchInvoices = async ()=>{\n    try {\n        console.log(\"Client: Fetching invoices from API\");\n        const response = await fetch(\"/api/invoices\");\n        const result = await response.json();\n        if (result.success) {\n            console.log(\"Client: Successfully fetched\", result.count, \"invoices\");\n            return result.data;\n        } else {\n            console.error(\"Client: API returned error:\", result.error);\n            throw new Error(result.error);\n        }\n    } catch (error) {\n        console.error(\"Client: Error fetching invoices:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPbkosSUFBSTtRQUNwQixPQUFPO1lBQ0wzQixRQUFRTSxLQUFLLENBQUMsK0JBQStCd0ssT0FBT3hLLEtBQUs7WUFDekQsTUFBTSxJQUFJMEIsTUFBTThJLE9BQU94SyxLQUFLO1FBQzlCO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2ROLFFBQVFNLEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE1BQU1BO0lBQ1I7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi96b2hvLnRzP2U3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9ob1Byb2plY3Qge1xyXG4gIHByb2plY3RfaWQ6IHN0cmluZztcclxuICBwcm9qZWN0X25hbWU6IHN0cmluZzsgLy8gQ2hhbmdlZCBmcm9tIG5hbWUgdG8gcHJvamVjdF9uYW1lXHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbiAgc3RhdHVzOiBzdHJpbmc7XHJcbiAgc3RhcnRfZGF0ZTogc3RyaW5nO1xyXG4gIGVuZF9kYXRlPzogc3RyaW5nO1xyXG4gIGJ1ZGdldF9hbW91bnQ/OiBudW1iZXI7XHJcbiAgcmF0ZV9wZXJfaG91cj86IG51bWJlcjtcclxuICBjdXN0b21lcl9pZDogc3RyaW5nO1xyXG4gIGN1c3RvbWVyX25hbWU6IHN0cmluZztcclxuICBzaWduZWRfZmVlPzogbnVtYmVyOyAvLyBBZGRlZCBmb3IgU2lnbmVkIEZlZSBmcm9tIFpvaG9cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBab2hvSW52b2ljZSB7XHJcbiAgaW52b2ljZV9pZDogc3RyaW5nO1xyXG4gIHByb2plY3RfaWQ6IHN0cmluZztcclxuICBpbnZvaWNlX251bWJlcjogc3RyaW5nO1xyXG4gIGRhdGU6IHN0cmluZztcclxuICBhbW91bnQ6IG51bWJlcjtcclxuICBzdGF0dXM6IHN0cmluZztcclxuICBiaWxsZWRfYW1vdW50OiBudW1iZXI7XHJcbiAgdW5iaWxsZWRfYW1vdW50OiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUb2tlblJlc3BvbnNlIHtcclxuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcclxuICBleHBpcmVzX2luOiBudW1iZXI7XHJcbiAgYXBpX2RvbWFpbjogc3RyaW5nO1xyXG4gIHRva2VuX3R5cGU6IHN0cmluZztcclxuICByZWZyZXNoX3Rva2VuPzogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBab2hvU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSB0b2tlbkV4cGlyeTogbnVtYmVyID0gMDtcclxuICBwcml2YXRlIHJlZnJlc2hQcm9taXNlOiBQcm9taXNlPHN0cmluZz4gfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IFRPS0VOX1JFRlJFU0hfQlVGRkVSID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzIGJ1ZmZlclxyXG4gIHByaXZhdGUgYXV0b1JlZnJlc2hUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IEFVVE9fUkVGUkVTSF9JTlRFUlZBTCA9IDQ1ICogNjAgKiAxMDAwOyAvLyA0NSBtaW51dGVzXHJcbiAgcHJpdmF0ZSBsYXN0UmVmcmVzaFRpbWU6IG51bWJlciA9IDA7IC8vIFRyYWNrIHdoZW4gYXV0by1yZWZyZXNoIHdhcyBsYXN0IHRyaWdnZXJlZFxyXG4gIFxyXG4gIC8vIFJhdGUgbGltaXRpbmcgcHJvcGVydGllc1xyXG4gIHByaXZhdGUgcmVxdWVzdENvdW50OiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgbGFzdFJlcXVlc3RUaW1lOiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUgPSAzMDsgLy8gQ29uc2VydmF0aXZlIGxpbWl0XHJcbiAgcHJpdmF0ZSByZWFkb25seSBNSU5fUkVRVUVTVF9JTlRFUlZBTCA9IDIwMDA7IC8vIDIgc2Vjb25kcyBiZXR3ZWVuIHJlcXVlc3RzXHJcbiAgcHJpdmF0ZSByZXRyeUNvdW50OiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX1JFVFJJRVMgPSAzO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgQkFTRV9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kIGJhc2UgZGVsYXkgZm9yIGV4cG9uZW50aWFsIGJhY2tvZmZcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBTdGFydCBhdXRvbWF0aWMgdG9rZW4gcmVmcmVzaFxyXG4gICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RhcnRBdXRvUmVmcmVzaCgpOiB2b2lkIHtcclxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lclxyXG4gICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUaW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuYXV0b1JlZnJlc2hUaW1lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IHVwIGF1dG9tYXRpYyByZWZyZXNoIGV2ZXJ5IDQ1IG1pbnV0ZXNcclxuICAgIHRoaXMuYXV0b1JlZnJlc2hUaW1lciA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXV0by1yZWZyZXNoaW5nIFpvaG8gdG9rZW4gKDQ1LW1pbnV0ZSBpbnRlcnZhbCkuLi4nKTtcclxuICAgICAgICB0aGlzLmxhc3RSZWZyZXNoVGltZSA9IERhdGUubm93KCk7IC8vIFRyYWNrIHdoZW4gcmVmcmVzaCB3YXMgdHJpZ2dlcmVkXHJcbiAgICAgICAgYXdhaXQgdGhpcy5mb3JjZVJlZnJlc2hUb2tlbigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdBdXRvLXJlZnJlc2ggY29tcGxldGVkIHN1Y2Nlc3NmdWxseScpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8tcmVmcmVzaCBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzLkFVVE9fUkVGUkVTSF9JTlRFUlZBTCk7XHJcblxyXG4gICAgLy8gU2V0IGluaXRpYWwgcmVmcmVzaCB0aW1lXHJcbiAgICB0aGlzLmxhc3RSZWZyZXNoVGltZSA9IERhdGUubm93KCk7XHJcbiAgICBjb25zb2xlLmxvZygnQXV0b21hdGljIFpvaG8gdG9rZW4gcmVmcmVzaCBzdGFydGVkIChldmVyeSA0NSBtaW51dGVzKScpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RvcEF1dG9SZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUaW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuYXV0b1JlZnJlc2hUaW1lcik7XHJcbiAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaW1lciA9IG51bGw7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRvbWF0aWMgWm9obyB0b2tlbiByZWZyZXNoIHN0b3BwZWQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIC8vIENoZWNrIGlmIHRva2VuIGlzIHN0aWxsIHZhbGlkICh3aXRoIGJ1ZmZlcilcclxuICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICYmIERhdGUubm93KCkgPCAodGhpcy50b2tlbkV4cGlyeSAtIHRoaXMuVE9LRU5fUkVGUkVTSF9CVUZGRVIpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBhIHJlZnJlc2ggaW4gcHJvZ3Jlc3MsIHdhaXQgZm9yIGl0XHJcbiAgICBpZiAodGhpcy5yZWZyZXNoUHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWZyZXNoUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFydCBhIG5ldyByZWZyZXNoXHJcbiAgICB0aGlzLnJlZnJlc2hQcm9taXNlID0gdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5yZWZyZXNoUHJvbWlzZTtcclxuICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdGhpcy5yZWZyZXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbigpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2hpbmcgWm9obyBhY2Nlc3MgdG9rZW4uLi4nKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSBmb3JtIGRhdGEgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ3JlZnJlc2hfdG9rZW4nLCBwcm9jZXNzLmVudi5aT0hPX1JFRlJFU0hfVE9LRU4gfHwgJycpO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2NsaWVudF9pZCcsIHByb2Nlc3MuZW52LlpPSE9fQ0xJRU5UX0lEIHx8ICcnKTtcclxuICAgICAgZm9ybURhdGEuYXBwZW5kKCdjbGllbnRfc2VjcmV0JywgcHJvY2Vzcy5lbnYuWk9IT19DTElFTlRfU0VDUkVUIHx8ICcnKTtcclxuICAgICAgZm9ybURhdGEuYXBwZW5kKCdncmFudF90eXBlJywgJ3JlZnJlc2hfdG9rZW4nKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdDxUb2tlblJlc3BvbnNlPignaHR0cHM6Ly9hY2NvdW50cy56b2hvLmNvbS9vYXV0aC92Mi90b2tlbicsIGZvcm1EYXRhLCB7XHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHJlc3BvbnNlLmRhdGEuYWNjZXNzX3Rva2VuO1xyXG4gICAgICB0aGlzLnRva2VuRXhwaXJ5ID0gRGF0ZS5ub3coKSArIChyZXNwb25zZS5kYXRhLmV4cGlyZXNfaW4gKiAxMDAwKTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBUb2tlbiByZWZyZXNoZWQgc3VjY2Vzc2Z1bGx5LiBFeHBpcmVzIGluICR7TWF0aC5yb3VuZChyZXNwb25zZS5kYXRhLmV4cGlyZXNfaW4gLyA2MCl9IG1pbnV0ZXNgKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmcmVzaGluZyBab2hvIGFjY2VzcyB0b2tlbjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIFpvaG8nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbWFrZVJlcXVlc3QoZW5kcG9pbnQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBBcHBseSByYXRlIGxpbWl0aW5nXHJcbiAgICAgIGF3YWl0IHRoaXMuYXBwbHlSYXRlTGltaXQoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYGh0dHBzOi8vd3d3LnpvaG9hcGlzLmNvbS9ib29rcy92My8ke2VuZHBvaW50fWAsIHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgb3JnYW5pemF0aW9uX2lkOiBwcm9jZXNzLmVudi5aT0hPX09SR0FOSVpBVElPTl9JRCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRpbWVvdXQ6IDMwMDAwLCAvLyAzMCBzZWNvbmQgdGltZW91dFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFJlc2V0IHJldHJ5IGNvdW50IG9uIHN1Y2Nlc3NcclxuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcclxuICAgICAgdGhpcy5yZXF1ZXN0Q291bnQrKztcclxuICAgICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nICg0MDAgd2l0aCBzcGVjaWZpYyBlcnJvciBtZXNzYWdlKVxyXG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAwICYmIFxyXG4gICAgICAgICAgZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yID09PSAnQWNjZXNzIERlbmllZCcgJiZcclxuICAgICAgICAgIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcl9kZXNjcmlwdGlvbj8uaW5jbHVkZXMoJ3RvbyBtYW55IHJlcXVlc3RzJykpIHtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygnWm9obyByYXRlIGxpbWl0IGhpdCwgaW1wbGVtZW50aW5nIGV4cG9uZW50aWFsIGJhY2tvZmYuLi4nKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVJhdGVMaW1pdCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGFmdGVyIGJhY2tvZmZcclxuICAgICAgICBpZiAodGhpcy5yZXRyeUNvdW50IDwgdGhpcy5NQVhfUkVUUklFUykge1xyXG4gICAgICAgICAgdGhpcy5yZXRyeUNvdW50Kys7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnlpbmcgcmVxdWVzdCBhZnRlciByYXRlIGxpbWl0IGJhY2tvZmYgKGF0dGVtcHQgJHt0aGlzLnJldHJ5Q291bnR9KWApO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoZW5kcG9pbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvaG8gQVBJIHJhdGUgbGltaXQgZXhjZWVkZWQgYWZ0ZXIgbWF4aW11bSByZXRyaWVzLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgd2UgZ2V0IGEgNDAxLCB0cnkgcmVmcmVzaGluZyB0aGUgdG9rZW4gb25jZVxyXG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAxKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Rva2VuIGV4cGlyZWQsIHJlZnJlc2hpbmcuLi4nKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDbGVhciB0aGUgY3VycmVudCB0b2tlbiBhbmQgZm9yY2UgYSByZWZyZXNoXHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b2tlbkV4cGlyeSA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1Rva2VuID0gYXdhaXQgdGhpcy5mb3JjZVJlZnJlc2hUb2tlbigpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCB3aXRoIHRoZSBuZXcgdG9rZW5cclxuICAgICAgICAgIGNvbnN0IHJldHJ5UmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYGh0dHBzOi8vd3d3LnpvaG9hcGlzLmNvbS9ib29rcy92My8ke2VuZHBvaW50fWAsIHtcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke25ld1Rva2VufWAsXHJcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgb3JnYW5pemF0aW9uX2lkOiBwcm9jZXNzLmVudi5aT0hPX09SR0FOSVpBVElPTl9JRCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGltZW91dDogMzAwMDAsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgcmV0cnkgc3VjY2Vzc2Z1bCBhZnRlciB0b2tlbiByZWZyZXNoJyk7XHJcbiAgICAgICAgICByZXR1cm4gcmV0cnlSZXNwb25zZS5kYXRhO1xyXG4gICAgICAgIH0gY2F0Y2ggKHJlZnJlc2hFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlZnJlc2ggdG9rZW4gb3IgcmV0cnkgcmVxdWVzdDonLCByZWZyZXNoRXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBab2hvIEFQSSBhdXRoZW50aWNhdGlvbiBmYWlsZWQgYWZ0ZXIgdG9rZW4gcmVmcmVzaDogJHtlbmRwb2ludH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSBvdGhlciBIVFRQIGVycm9yc1xyXG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFpvaG8gQVBJIGVycm9yICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfSBmb3IgJHtlbmRwb2ludH06YCwgZXJyb3IucmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUHJvdmlkZSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvaG8gQVBJIGFjY2VzcyBmb3JiaWRkZW4gLSBjaGVjayB5b3VyIG9yZ2FuaXphdGlvbiBJRCBhbmQgcGVybWlzc2lvbnMnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvaG8gQVBJIHJhdGUgbGltaXQgZXhjZWVkZWQgLSBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPj0gNTAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvaG8gQVBJIHNlcnZlciBlcnJvciAtIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBab2hvIEFQSSBlcnJvciAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3IucmVzcG9uc2UuZGF0YT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIG1ha2luZyBab2hvIHJlcXVlc3QgdG8gJHtlbmRwb2ludH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBkYXRhIGZyb20gWm9obzogJHtlbmRwb2ludH1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgYXBwbHlSYXRlTGltaXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHdhaXQgYmV0d2VlbiByZXF1ZXN0c1xyXG4gICAgaWYgKHRoaXMubGFzdFJlcXVlc3RUaW1lID4gMCkge1xyXG4gICAgICBjb25zdCB0aW1lU2luY2VMYXN0UmVxdWVzdCA9IG5vdyAtIHRoaXMubGFzdFJlcXVlc3RUaW1lO1xyXG4gICAgICBpZiAodGltZVNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLk1JTl9SRVFVRVNUX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgY29uc3Qgd2FpdFRpbWUgPSB0aGlzLk1JTl9SRVFVRVNUX0lOVEVSVkFMIC0gdGltZVNpbmNlTGFzdFJlcXVlc3Q7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFJhdGUgbGltaXRpbmc6IHdhaXRpbmcgJHt3YWl0VGltZX1tcyBiZWZvcmUgbmV4dCByZXF1ZXN0YCk7XHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXRUaW1lKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgZXhjZWVkZWQgdGhlIHBlci1taW51dGUgbGltaXRcclxuICAgIGlmICh0aGlzLnJlcXVlc3RDb3VudCA+PSB0aGlzLk1BWF9SRVFVRVNUU19QRVJfTUlOVVRFKSB7XHJcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0UmVxdWVzdCA9IG5vdyAtIHRoaXMubGFzdFJlcXVlc3RUaW1lO1xyXG4gICAgICBpZiAodGltZVNpbmNlRmlyc3RSZXF1ZXN0IDwgNjAwMDApIHsgLy8gTGVzcyB0aGFuIDEgbWludXRlXHJcbiAgICAgICAgY29uc3Qgd2FpdFRpbWUgPSA2MDAwMCAtIHRpbWVTaW5jZUZpcnN0UmVxdWVzdDtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUmF0ZSBsaW1pdGluZzogZXhjZWVkZWQgJHt0aGlzLk1BWF9SRVFVRVNUU19QRVJfTUlOVVRFfSByZXF1ZXN0cyBwZXIgbWludXRlLCB3YWl0aW5nICR7d2FpdFRpbWV9bXNgKTtcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgd2FpdFRpbWUpKTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gUmVzZXQgY291bnRlciBpZiBtb3JlIHRoYW4gMSBtaW51dGUgaGFzIHBhc3NlZFxyXG4gICAgICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSYXRlTGltaXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBkZWxheSA9IHRoaXMuQkFTRV9ERUxBWSAqIE1hdGgucG93KDIsIHRoaXMucmV0cnlDb3VudCk7XHJcbiAgICBjb25zb2xlLmxvZyhgUmF0ZSBsaW1pdCBiYWNrb2ZmOiB3YWl0aW5nICR7ZGVsYXl9bXMgYmVmb3JlIHJldHJ5YCk7XHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcclxuICAgIFxyXG4gICAgLy8gUmVzZXQgcmVxdWVzdCBjb3VudGVycyB0byBhbGxvdyBmcmVzaCBzdGFydFxyXG4gICAgdGhpcy5yZXF1ZXN0Q291bnQgPSAwO1xyXG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSAwO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdHMoKTogUHJvbWlzZTxab2hvUHJvamVjdFtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgYWxsUHJvamVjdHM6IFpvaG9Qcm9qZWN0W10gPSBbXTtcclxuICAgICAgbGV0IHBhZ2UgPSAxO1xyXG4gICAgICBjb25zdCBwZXJQYWdlID0gMjAwO1xyXG4gICAgICBcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcHJvamVjdHM/cGFnZT0ke3BhZ2V9JnBlcl9wYWdlPSR7cGVyUGFnZX1gKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBwcm9qZWN0cyA9IGRhdGEucHJvamVjdHM/Lm1hcCgocHJvamVjdDogYW55KSA9PiB7XHJcbiAgICAgICAgICAvLyBMb2cgdGhlIGZpcnN0IHByb2plY3QgdG8gc2VlIGF2YWlsYWJsZSBmaWVsZHNcclxuICAgICAgICAgIGlmIChwYWdlID09PSAxICYmIGFsbFByb2plY3RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2FtcGxlIFpvaG8gcHJvamVjdCBkYXRhOicsIEpTT04uc3RyaW5naWZ5KHByb2plY3QsIG51bGwsIDIpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvamVjdF9pZDogcHJvamVjdC5wcm9qZWN0X2lkLFxyXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3QucHJvamVjdF9uYW1lIHx8IHByb2plY3QubmFtZSB8fCAnJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHByb2plY3QuZGVzY3JpcHRpb24gfHwgJycsXHJcbiAgICAgICAgICAgIHN0YXR1czogcHJvamVjdC5zdGF0dXMgfHwgJ2FjdGl2ZScsXHJcbiAgICAgICAgICAgIHN0YXJ0X2RhdGU6IHByb2plY3Quc3RhcnRfZGF0ZSB8fCAnJyxcclxuICAgICAgICAgICAgZW5kX2RhdGU6IHByb2plY3QuZW5kX2RhdGUgfHwgJycsXHJcbiAgICAgICAgICAgIGJ1ZGdldF9hbW91bnQ6IHByb2plY3QuYnVkZ2V0X2Ftb3VudCB8fCAwLFxyXG4gICAgICAgICAgICByYXRlX3Blcl9ob3VyOiBwcm9qZWN0LnJhdGVfcGVyX2hvdXIgfHwgMCxcclxuICAgICAgICAgICAgY3VzdG9tZXJfaWQ6IHByb2plY3QuY3VzdG9tZXJfaWQgfHwgJycsXHJcbiAgICAgICAgICAgIGN1c3RvbWVyX25hbWU6IHByb2plY3QuY3VzdG9tZXJfbmFtZSB8fCAnJyxcclxuICAgICAgICAgICAgc2lnbmVkX2ZlZTogdW5kZWZpbmVkLCAvLyBSZW1vdmUgWm9obyBzaWduZWQgZmVlLCBvbmx5IHVzZSB1c2VyLWVudGVyZWQgZGF0YVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KSB8fCBbXTtcclxuICAgICAgICBcclxuICAgICAgICBhbGxQcm9qZWN0cyA9IGFsbFByb2plY3RzLmNvbmNhdChwcm9qZWN0cyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kXHJcbiAgICAgICAgaWYgKHByb2plY3RzLmxlbmd0aCA8IHBlclBhZ2UpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwYWdlKys7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGVkICR7YWxsUHJvamVjdHMubGVuZ3RofSBwcm9qZWN0cyBmcm9tIFpvaG9gKTtcclxuICAgICAgcmV0dXJuIGFsbFByb2plY3RzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0c1dpdGhSZXZlbnVlQnVkZ2V0KCk6IFByb21pc2U8Wm9ob1Byb2plY3RbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHByb2plY3RzIHdpdGggcmV2ZW51ZSBidWRnZXQgZGF0YS4uLicpO1xyXG4gICAgICBjb25zdCBwcm9qZWN0cyA9IGF3YWl0IHRoaXMuZ2V0UHJvamVjdHMoKTtcclxuICAgICAgXHJcbiAgICAgIC8vIExvZyBwcm9qZWN0cyB0aGF0IGhhdmUgcmV2ZW51ZV9idWRnZXQgZGF0YVxyXG4gICAgICBjb25zdCBwcm9qZWN0c1dpdGhSZXZlbnVlQnVkZ2V0ID0gcHJvamVjdHMuZmlsdGVyKHByb2plY3QgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhhc1JldmVudWVCdWRnZXQgPSBwcm9qZWN0LnNpZ25lZF9mZWUgJiYgcHJvamVjdC5zaWduZWRfZmVlID4gMDtcclxuICAgICAgICBpZiAoaGFzUmV2ZW51ZUJ1ZGdldCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFByb2plY3QgJHtwcm9qZWN0LnByb2plY3RfbmFtZX0gaGFzIHJldmVudWUgYnVkZ2V0OiAkJHtwcm9qZWN0LnNpZ25lZF9mZWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNSZXZlbnVlQnVkZ2V0O1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3Byb2plY3RzV2l0aFJldmVudWVCdWRnZXQubGVuZ3RofSBwcm9qZWN0cyB3aXRoIHJldmVudWUgYnVkZ2V0IGRhdGFgKTtcclxuICAgICAgcmV0dXJuIHByb2plY3RzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHMgd2l0aCByZXZlbnVlIGJ1ZGdldDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGRlYnVnUHJvamVjdEZpZWxkcygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEZWJ1Z2dpbmcgWm9obyBwcm9qZWN0IGZpZWxkcy4uLicpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgncHJvamVjdHM/cGFnZT0xJnBlcl9wYWdlPTUnKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChkYXRhLnByb2plY3RzICYmIGRhdGEucHJvamVjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdBdmFpbGFibGUgZmllbGRzIGluIFpvaG8gcHJvamVjdCByZXNwb25zZTonKTtcclxuICAgICAgICBjb25zdCBzYW1wbGVQcm9qZWN0ID0gZGF0YS5wcm9qZWN0c1swXTtcclxuICAgICAgICBPYmplY3Qua2V5cyhzYW1wbGVQcm9qZWN0KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAke2tleX06ICR7c2FtcGxlUHJvamVjdFtrZXldfSAoJHt0eXBlb2Ygc2FtcGxlUHJvamVjdFtrZXldfSlgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBzcGVjaWZpY2FsbHkgZm9yIHJldmVudWVfYnVkZ2V0XHJcbiAgICAgICAgaWYgKHNhbXBsZVByb2plY3QucmV2ZW51ZV9idWRnZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCByZXZlbnVlX2J1ZGdldCBmaWVsZDogJHtzYW1wbGVQcm9qZWN0LnJldmVudWVfYnVkZ2V0fWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4p2MIHJldmVudWVfYnVkZ2V0IGZpZWxkIG5vdCBmb3VuZCBpbiBab2hvIHJlc3BvbnNlJyk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQXZhaWxhYmxlIGJ1ZGdldC1yZWxhdGVkIGZpZWxkczonKTtcclxuICAgICAgICAgIE9iamVjdC5rZXlzKHNhbXBsZVByb2plY3QpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdidWRnZXQnKSB8fCBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmV2ZW51ZScpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgJHtrZXl9OiAke3NhbXBsZVByb2plY3Rba2V5XX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBwcm9qZWN0cyBmb3VuZCBpbiBab2hvIHJlc3BvbnNlJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlYnVnZ2luZyBwcm9qZWN0IGZpZWxkczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0c1dpdGhFc3RpbWF0ZXMoKTogUHJvbWlzZTxab2hvUHJvamVjdFtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwcm9qZWN0cyA9IGF3YWl0IHRoaXMuZ2V0UHJvamVjdHMoKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEZvciB0aGUgZmlyc3QgZmV3IHByb2plY3RzLCB0cnkgdG8gZ2V0IGVzdGltYXRlcyB0byBzZWUgaWYgdGhhdCBjb250YWlucyB0aGUgc2lnbmVkIGZlZVxyXG4gICAgICBjb25zdCBwcm9qZWN0c1dpdGhFc3RpbWF0ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgICBwcm9qZWN0cy5zbGljZSgwLCA1KS5tYXAoYXN5bmMgKHByb2plY3QpID0+IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlcyA9IGF3YWl0IHRoaXMuZ2V0UHJvamVjdEVzdGltYXRlcyhwcm9qZWN0LnByb2plY3RfaWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbEVzdGltYXRlQW1vdW50ID0gZXN0aW1hdGVzLnJlZHVjZSgoc3VtLCBlc3RpbWF0ZSkgPT4gc3VtICsgKGVzdGltYXRlLnRvdGFsIHx8IDApLCAwKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9qZWN0ICR7cHJvamVjdC5wcm9qZWN0X25hbWV9IGVzdGltYXRlczpgLCBlc3RpbWF0ZXMubGVuZ3RoLCAndG90YWwgYW1vdW50OicsIHRvdGFsRXN0aW1hdGVBbW91bnQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5wcm9qZWN0LFxyXG4gICAgICAgICAgICAgIHNpZ25lZF9mZWU6IHByb2plY3Quc2lnbmVkX2ZlZSB8fCB0b3RhbEVzdGltYXRlQW1vdW50IHx8IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBlc3RpbWF0ZXMgZm9yIHByb2plY3QgJHtwcm9qZWN0LnByb2plY3RfaWR9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJldHVybiBhbGwgcHJvamVjdHMsIHdpdGggdGhlIGZpcnN0IDUgaGF2aW5nIHVwZGF0ZWQgc2lnbmVkIGZlZXMgZnJvbSBlc3RpbWF0ZXNcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICAuLi5wcm9qZWN0c1dpdGhFc3RpbWF0ZXMsXHJcbiAgICAgICAgLi4ucHJvamVjdHMuc2xpY2UoNSlcclxuICAgICAgXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3RzIHdpdGggZXN0aW1hdGVzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdHNXaXRoSW52b2ljZVRvdGFscygpOiBQcm9taXNlPFpvaG9Qcm9qZWN0W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IFtwcm9qZWN0cywgaW52b2ljZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHRoaXMuZ2V0UHJvamVjdHMoKSxcclxuICAgICAgICB0aGlzLmdldEludm9pY2VzKCksXHJcbiAgICAgIF0pO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2FsY3VsYXRlIHNpZ25lZCBmZWUgYXMgdG90YWwgb2YgYWxsIGludm9pY2VzIGZvciBlYWNoIHByb2plY3RcclxuICAgICAgY29uc3QgcHJvamVjdHNXaXRoSW52b2ljZVRvdGFscyA9IHByb2plY3RzLm1hcChwcm9qZWN0ID0+IHtcclxuICAgICAgICBjb25zdCBwcm9qZWN0SW52b2ljZXMgPSBpbnZvaWNlcy5maWx0ZXIoaW52b2ljZSA9PiBpbnZvaWNlLnByb2plY3RfaWQgPT09IHByb2plY3QucHJvamVjdF9pZCk7XHJcbiAgICAgICAgY29uc3QgdG90YWxJbnZvaWNlQW1vdW50ID0gcHJvamVjdEludm9pY2VzLnJlZHVjZSgoc3VtLCBpbnZvaWNlKSA9PiBzdW0gKyBpbnZvaWNlLmFtb3VudCwgMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYFByb2plY3QgJHtwcm9qZWN0LnByb2plY3RfbmFtZX0gaW52b2ljZXM6YCwgcHJvamVjdEludm9pY2VzLmxlbmd0aCwgJ3RvdGFsIGFtb3VudDonLCB0b3RhbEludm9pY2VBbW91bnQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAuLi5wcm9qZWN0LFxyXG4gICAgICAgICAgc2lnbmVkX2ZlZTogcHJvamVjdC5zaWduZWRfZmVlIHx8IHRvdGFsSW52b2ljZUFtb3VudCB8fCAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHByb2plY3RzV2l0aEludm9pY2VUb3RhbHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0cyB3aXRoIGludm9pY2UgdG90YWxzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0SW52b2ljZXMoKTogUHJvbWlzZTxab2hvSW52b2ljZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnaW52b2ljZXMnKTtcclxuICAgICAgcmV0dXJuIGRhdGEuaW52b2ljZXM/Lm1hcCgoaW52b2ljZTogYW55KSA9PiAoe1xyXG4gICAgICAgIGludm9pY2VfaWQ6IGludm9pY2UuaW52b2ljZV9pZCxcclxuICAgICAgICBwcm9qZWN0X2lkOiBpbnZvaWNlLnByb2plY3RfaWQsXHJcbiAgICAgICAgaW52b2ljZV9udW1iZXI6IGludm9pY2UuaW52b2ljZV9udW1iZXIsXHJcbiAgICAgICAgZGF0ZTogaW52b2ljZS5kYXRlLFxyXG4gICAgICAgIGFtb3VudDogaW52b2ljZS50b3RhbCxcclxuICAgICAgICBzdGF0dXM6IGludm9pY2Uuc3RhdHVzLFxyXG4gICAgICAgIGJpbGxlZF9hbW91bnQ6IGludm9pY2UuYmlsbGVkX2Ftb3VudCB8fCAwLFxyXG4gICAgICAgIHVuYmlsbGVkX2Ftb3VudDogaW52b2ljZS51bmJpbGxlZF9hbW91bnQgfHwgMCxcclxuICAgICAgfSkpIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgaW52b2ljZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0SW52b2ljZXMocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFpvaG9JbnZvaWNlW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGBwcm9qZWN0cy8ke3Byb2plY3RJZH0vaW52b2ljZXNgKTtcclxuICAgICAgcmV0dXJuIGRhdGEuaW52b2ljZXM/Lm1hcCgoaW52b2ljZTogYW55KSA9PiAoe1xyXG4gICAgICAgIGludm9pY2VfaWQ6IGludm9pY2UuaW52b2ljZV9pZCxcclxuICAgICAgICBwcm9qZWN0X2lkOiBpbnZvaWNlLnByb2plY3RfaWQsXHJcbiAgICAgICAgaW52b2ljZV9udW1iZXI6IGludm9pY2UuaW52b2ljZV9udW1iZXIsXHJcbiAgICAgICAgZGF0ZTogaW52b2ljZS5kYXRlLFxyXG4gICAgICAgIGFtb3VudDogaW52b2ljZS50b3RhbCxcclxuICAgICAgICBzdGF0dXM6IGludm9pY2Uuc3RhdHVzLFxyXG4gICAgICAgIGJpbGxlZF9hbW91bnQ6IGludm9pY2UuYmlsbGVkX2Ftb3VudCB8fCAwLFxyXG4gICAgICAgIHVuYmlsbGVkX2Ftb3VudDogaW52b2ljZS51bmJpbGxlZF9hbW91bnQgfHwgMCxcclxuICAgICAgfSkpIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdCBpbnZvaWNlczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3REZXRhaWxzKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGBwcm9qZWN0cy8ke3Byb2plY3RJZH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYFByb2plY3QgJHtwcm9qZWN0SWR9IGRldGFpbHM6YCwgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3QgZGV0YWlsczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdEVzdGltYXRlcyhwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGBwcm9qZWN0cy8ke3Byb2plY3RJZH0vZXN0aW1hdGVzYCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9qZWN0ICR7cHJvamVjdElkfSBlc3RpbWF0ZXM6YCwgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YS5lc3RpbWF0ZXMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0IGVzdGltYXRlczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RDb250cmFjdHMocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcHJvamVjdHMvJHtwcm9qZWN0SWR9L2NvbnRyYWN0c2ApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgUHJvamVjdCAke3Byb2plY3RJZH0gY29udHJhY3RzOmAsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGEuY29udHJhY3RzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdCBjb250cmFjdHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOZXcgbWV0aG9kIHRvIGdldCBQcm9maXQgJiBMb3NzIHN0YXRlbWVudFxyXG4gIGFzeW5jIGdldFByb2ZpdEFuZExvc3Moc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcmVwb3J0cy9wcm9maXRhbmRsb3NzP2Zyb21fZGF0ZT0ke3N0YXJ0RGF0ZX0mdG9fZGF0ZT0ke2VuZERhdGV9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdQcm9maXQgJiBMb3NzIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFByb2ZpdCAmIExvc3M6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5ldyBtZXRob2QgdG8gZ2V0IENhc2ggRmxvdyBzdGF0ZW1lbnRcclxuICBhc3luYyBnZXRDYXNoRmxvdyhzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGByZXBvcnRzL2Nhc2hmbG93P2Zyb21fZGF0ZT0ke3N0YXJ0RGF0ZX0mdG9fZGF0ZT0ke2VuZERhdGV9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDYXNoIEZsb3cgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgQ2FzaCBGbG93OicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOZXcgbWV0aG9kIHRvIGdldCBCYWxhbmNlIFNoZWV0XHJcbiAgYXN5bmMgZ2V0QmFsYW5jZVNoZWV0KGRhdGU6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgcmVwb3J0cy9iYWxhbmNlc2hlZXQ/ZGF0ZT0ke2RhdGV9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdCYWxhbmNlIFNoZWV0IGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIEJhbGFuY2UgU2hlZXQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5ldyBtZXRob2QgdG8gZ2V0IENoYXJ0IG9mIEFjY291bnRzXHJcbiAgYXN5bmMgZ2V0Q2hhcnRPZkFjY291bnRzKCk6IFByb21pc2U8YW55W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCdjaGFydG9mYWNjb3VudHMnKTtcclxuICAgICAgY29uc29sZS5sb2coJ0NoYXJ0IG9mIEFjY291bnRzIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YS5jaGFydG9mYWNjb3VudHMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBDaGFydCBvZiBBY2NvdW50czonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5ldyBtZXRob2QgdG8gZ2V0IEpvdXJuYWwgRW50cmllcyBmb3IgYSBkYXRlIHJhbmdlXHJcbiAgYXN5bmMgZ2V0Sm91cm5hbEVudHJpZXMoc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGBqb3VybmFsZW50cmllcz9mcm9tX2RhdGU9JHtzdGFydERhdGV9JnRvX2RhdGU9JHtlbmREYXRlfWApO1xyXG4gICAgICBjb25zb2xlLmxvZygnSm91cm5hbCBFbnRyaWVzIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YS5qb3VybmFsZW50cmllcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIEpvdXJuYWwgRW50cmllczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5ldyBtZXRob2QgdG8gZ2V0IGNvbXByZWhlbnNpdmUgZmluYW5jaWFsIG1ldHJpY3NcclxuICBhc3luYyBnZXRGaW5hbmNpYWxNZXRyaWNzKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIHJldmVudWU6IG51bWJlcjtcclxuICAgIGV4cGVuc2VzOiBudW1iZXI7XHJcbiAgICBncm9zc1Byb2ZpdDogbnVtYmVyO1xyXG4gICAgbmV0UHJvZml0OiBudW1iZXI7XHJcbiAgICBvcGVyYXRpbmdJbmNvbWU6IG51bWJlcjtcclxuICAgIGNhc2hGbG93OiBudW1iZXI7XHJcbiAgICBhY2NvdW50c1JlY2VpdmFibGU6IG51bWJlcjtcclxuICAgIGFjY291bnRzUGF5YWJsZTogbnVtYmVyO1xyXG4gICAgY2FzaEJhbGFuY2U6IG51bWJlcjtcclxuICB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBbcGxEYXRhLCBjZkRhdGEsIGJzRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgdGhpcy5nZXRQcm9maXRBbmRMb3NzKHN0YXJ0RGF0ZSwgZW5kRGF0ZSksXHJcbiAgICAgICAgdGhpcy5nZXRDYXNoRmxvdyhzdGFydERhdGUsIGVuZERhdGUpLFxyXG4gICAgICAgIHRoaXMuZ2V0QmFsYW5jZVNoZWV0KGVuZERhdGUpXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgLy8gRXh0cmFjdCBmaW5hbmNpYWwgbWV0cmljcyBmcm9tIHRoZSByZXNwb25zZXNcclxuICAgICAgY29uc3QgcmV2ZW51ZSA9IHBsRGF0YT8ucmV2ZW51ZT8udG90YWwgfHwgMDtcclxuICAgICAgY29uc3QgZXhwZW5zZXMgPSBwbERhdGE/LmV4cGVuc2VzPy50b3RhbCB8fCAwO1xyXG4gICAgICBjb25zdCBncm9zc1Byb2ZpdCA9IHJldmVudWUgLSBleHBlbnNlcztcclxuICAgICAgXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBuZXQgcHJvZml0IChtYXkgbmVlZCBhZGp1c3RtZW50IGJhc2VkIG9uIGFjdHVhbCBab2hvIHJlc3BvbnNlIHN0cnVjdHVyZSlcclxuICAgICAgY29uc3QgbmV0UHJvZml0ID0gZ3Jvc3NQcm9maXQgLSAocGxEYXRhPy5vcGVyYXRpbmdfZXhwZW5zZXM/LnRvdGFsIHx8IDApO1xyXG4gICAgICBjb25zdCBvcGVyYXRpbmdJbmNvbWUgPSBncm9zc1Byb2ZpdCAtIChwbERhdGE/Lm9wZXJhdGluZ19leHBlbnNlcz8udG90YWwgfHwgMCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IGNhc2ggZmxvdyBkYXRhXHJcbiAgICAgIGNvbnN0IGNhc2hGbG93ID0gY2ZEYXRhPy5uZXRfY2FzaF9mbG93IHx8IDA7XHJcbiAgICAgIGNvbnN0IGFjY291bnRzUmVjZWl2YWJsZSA9IGJzRGF0YT8uY3VycmVudF9hc3NldHM/LmFjY291bnRzX3JlY2VpdmFibGUgfHwgMDtcclxuICAgICAgY29uc3QgYWNjb3VudHNQYXlhYmxlID0gYnNEYXRhPy5jdXJyZW50X2xpYWJpbGl0aWVzPy5hY2NvdW50c19wYXlhYmxlIHx8IDA7XHJcbiAgICAgIGNvbnN0IGNhc2hCYWxhbmNlID0gYnNEYXRhPy5jdXJyZW50X2Fzc2V0cz8uY2FzaF9hbmRfYmFuayB8fCAwO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZXZlbnVlLFxyXG4gICAgICAgIGV4cGVuc2VzLFxyXG4gICAgICAgIGdyb3NzUHJvZml0LFxyXG4gICAgICAgIG5ldFByb2ZpdCxcclxuICAgICAgICBvcGVyYXRpbmdJbmNvbWUsXHJcbiAgICAgICAgY2FzaEZsb3csXHJcbiAgICAgICAgYWNjb3VudHNSZWNlaXZhYmxlLFxyXG4gICAgICAgIGFjY291bnRzUGF5YWJsZSxcclxuICAgICAgICBjYXNoQmFsYW5jZVxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZmluYW5jaWFsIG1ldHJpY3M6JywgZXJyb3IpO1xyXG4gICAgICAvLyBSZXR1cm4gZGVmYXVsdCB2YWx1ZXMgaWYgQVBJIGNhbGxzIGZhaWxcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZXZlbnVlOiAwLFxyXG4gICAgICAgIGV4cGVuc2VzOiAwLFxyXG4gICAgICAgIGdyb3NzUHJvZml0OiAwLFxyXG4gICAgICAgIG5ldFByb2ZpdDogMCxcclxuICAgICAgICBvcGVyYXRpbmdJbmNvbWU6IDAsXHJcbiAgICAgICAgY2FzaEZsb3c6IDAsXHJcbiAgICAgICAgYWNjb3VudHNSZWNlaXZhYmxlOiAwLFxyXG4gICAgICAgIGFjY291bnRzUGF5YWJsZTogMCxcclxuICAgICAgICBjYXNoQmFsYW5jZTogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWV0aG9kIHRvIG1hbnVhbGx5IHJlZnJlc2ggdG9rZW4gKGZvciB0ZXN0aW5nKVxyXG4gIGFzeW5jIGZvcmNlUmVmcmVzaFRva2VuKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XHJcbiAgICB0aGlzLnRva2VuRXhwaXJ5ID0gMDtcclxuICAgIHRoaXMubGFzdFJlZnJlc2hUaW1lID0gRGF0ZS5ub3coKTsgLy8gVHJhY2sgbWFudWFsIHJlZnJlc2ggdGltZVxyXG4gICAgYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRva2VuIHN0YXR1cyBmb3IgZGVidWdnaW5nXHJcbiAgZ2V0VG9rZW5TdGF0dXMoKTogeyBoYXNUb2tlbjogYm9vbGVhbjsgZXhwaXJlc0luOiBudW1iZXI7IGlzRXhwaXJlZDogYm9vbGVhbiB9IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBoYXNUb2tlbjogISF0aGlzLmFjY2Vzc1Rva2VuLFxyXG4gICAgICBleHBpcmVzSW46IHRoaXMudG9rZW5FeHBpcnkgLSBub3csXHJcbiAgICAgIGlzRXhwaXJlZDogbm93ID49IHRoaXMudG9rZW5FeHBpcnksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gTWV0aG9kIHRvIGdldCBhdXRvLXJlZnJlc2ggc3RhdHVzXHJcbiAgZ2V0QXV0b1JlZnJlc2hTdGF0dXMoKTogeyBpc0FjdGl2ZTogYm9vbGVhbjsgbmV4dFJlZnJlc2hJbjogbnVtYmVyIH0ge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RSZWZyZXNoID0gbm93IC0gdGhpcy5sYXN0UmVmcmVzaFRpbWU7XHJcbiAgICBjb25zdCBuZXh0UmVmcmVzaEluID0gTWF0aC5tYXgoMCwgdGhpcy5BVVRPX1JFRlJFU0hfSU5URVJWQUwgLSB0aW1lU2luY2VMYXN0UmVmcmVzaCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzQWN0aXZlOiAhIXRoaXMuYXV0b1JlZnJlc2hUaW1lcixcclxuICAgICAgbmV4dFJlZnJlc2hJbixcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWMgbWV0aG9kIHRvIHN0YXJ0IGF1dG8tcmVmcmVzaFxyXG4gIGVuYWJsZUF1dG9SZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljIG1ldGhvZCB0byBzdG9wIGF1dG8tcmVmcmVzaFxyXG4gIGRpc2FibGVBdXRvUmVmcmVzaCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljIG1ldGhvZCB0byBnZXQgY29tcHJlaGVuc2l2ZSBzdGF0dXNcclxuICBnZXRTdGF0dXMoKTogeyBcclxuICAgIGhhc1Rva2VuOiBib29sZWFuOyBcclxuICAgIGV4cGlyZXNJbjogbnVtYmVyOyBcclxuICAgIGlzRXhwaXJlZDogYm9vbGVhbjtcclxuICAgIGF1dG9SZWZyZXNoOiB7IGlzQWN0aXZlOiBib29sZWFuOyBuZXh0UmVmcmVzaEluOiBudW1iZXIgfTtcclxuICB9IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLnRoaXMuZ2V0VG9rZW5TdGF0dXMoKSxcclxuICAgICAgYXV0b1JlZnJlc2g6IHRoaXMuZ2V0QXV0b1JlZnJlc2hTdGF0dXMoKSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgem9ob1NlcnZpY2UgPSBuZXcgWm9ob1NlcnZpY2UoKTsgXHJcblxyXG4vLyBFeHBvcnQgdGhlIGZ1bmN0aW9ucyB0aGF0IGFyZSBiZWluZyBpbXBvcnRlZCBpbiBwYWdlLnRzeFxyXG5leHBvcnQgY29uc3QgZmV0Y2hQcm9qZWN0cyA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ0NsaWVudDogRmV0Y2hpbmcgcHJvamVjdHMgZnJvbSBBUEknKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcHJvamVjdHMnKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDbGllbnQ6IFN1Y2Nlc3NmdWxseSBmZXRjaGVkJywgcmVzdWx0LmNvdW50LCAncHJvamVjdHMnKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQ2xpZW50OiBBUEkgcmV0dXJuZWQgZXJyb3I6JywgcmVzdWx0LmVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvcik7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NsaWVudDogRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGZldGNoSW52b2ljZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdDbGllbnQ6IEZldGNoaW5nIGludm9pY2VzIGZyb20gQVBJJyk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2ludm9pY2VzJyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICBjb25zb2xlLmxvZygnQ2xpZW50OiBTdWNjZXNzZnVsbHkgZmV0Y2hlZCcsIHJlc3VsdC5jb3VudCwgJ2ludm9pY2VzJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsaWVudDogQVBJIHJldHVybmVkIGVycm9yOicsIHJlc3VsdC5lcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDbGllbnQ6IEVycm9yIGZldGNoaW5nIGludm9pY2VzOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTsgIl0sIm5hbWVzIjpbImF4aW9zIiwiWm9ob1NlcnZpY2UiLCJfc3RhcnRBdXRvUmVmcmVzaCIsImF1dG9SZWZyZXNoVGltZXIiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjb25zb2xlIiwibG9nIiwibGFzdFJlZnJlc2hUaW1lIiwiRGF0ZSIsIm5vdyIsImZvcmNlUmVmcmVzaFRva2VuIiwiZXJyb3IiLCJBVVRPX1JFRlJFU0hfSU5URVJWQUwiLCJfc3RvcEF1dG9SZWZyZXNoIiwiZ2V0QWNjZXNzVG9rZW4iLCJhY2Nlc3NUb2tlbiIsInRva2VuRXhwaXJ5IiwiVE9LRU5fUkVGUkVTSF9CVUZGRVIiLCJyZWZyZXNoUHJvbWlzZSIsInJlZnJlc2hBY2Nlc3NUb2tlbiIsInRva2VuIiwiZm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJwcm9jZXNzIiwiZW52IiwiWk9IT19SRUZSRVNIX1RPS0VOIiwiWk9IT19DTElFTlRfSUQiLCJaT0hPX0NMSUVOVF9TRUNSRVQiLCJyZXNwb25zZSIsInBvc3QiLCJoZWFkZXJzIiwiZGF0YSIsImFjY2Vzc190b2tlbiIsImV4cGlyZXNfaW4iLCJNYXRoIiwicm91bmQiLCJFcnJvciIsIm1ha2VSZXF1ZXN0IiwiZW5kcG9pbnQiLCJhcHBseVJhdGVMaW1pdCIsImdldCIsInBhcmFtcyIsIm9yZ2FuaXphdGlvbl9pZCIsIlpPSE9fT1JHQU5JWkFUSU9OX0lEIiwidGltZW91dCIsInJldHJ5Q291bnQiLCJyZXF1ZXN0Q291bnQiLCJsYXN0UmVxdWVzdFRpbWUiLCJzdGF0dXMiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiaGFuZGxlUmF0ZUxpbWl0IiwiTUFYX1JFVFJJRVMiLCJuZXdUb2tlbiIsInJldHJ5UmVzcG9uc2UiLCJyZWZyZXNoRXJyb3IiLCJtZXNzYWdlIiwidGltZVNpbmNlTGFzdFJlcXVlc3QiLCJNSU5fUkVRVUVTVF9JTlRFUlZBTCIsIndhaXRUaW1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiTUFYX1JFUVVFU1RTX1BFUl9NSU5VVEUiLCJ0aW1lU2luY2VGaXJzdFJlcXVlc3QiLCJkZWxheSIsIkJBU0VfREVMQVkiLCJwb3ciLCJnZXRQcm9qZWN0cyIsImFsbFByb2plY3RzIiwicGFnZSIsInBlclBhZ2UiLCJwcm9qZWN0cyIsIm1hcCIsInByb2plY3QiLCJsZW5ndGgiLCJKU09OIiwic3RyaW5naWZ5IiwicHJvamVjdF9pZCIsInByb2plY3RfbmFtZSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInN0YXJ0X2RhdGUiLCJlbmRfZGF0ZSIsImJ1ZGdldF9hbW91bnQiLCJyYXRlX3Blcl9ob3VyIiwiY3VzdG9tZXJfaWQiLCJjdXN0b21lcl9uYW1lIiwic2lnbmVkX2ZlZSIsInVuZGVmaW5lZCIsImNvbmNhdCIsImdldFByb2plY3RzV2l0aFJldmVudWVCdWRnZXQiLCJwcm9qZWN0c1dpdGhSZXZlbnVlQnVkZ2V0IiwiZmlsdGVyIiwiaGFzUmV2ZW51ZUJ1ZGdldCIsImRlYnVnUHJvamVjdEZpZWxkcyIsInNhbXBsZVByb2plY3QiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInJldmVudWVfYnVkZ2V0IiwidG9Mb3dlckNhc2UiLCJnZXRQcm9qZWN0c1dpdGhFc3RpbWF0ZXMiLCJwcm9qZWN0c1dpdGhFc3RpbWF0ZXMiLCJhbGwiLCJzbGljZSIsImVzdGltYXRlcyIsImdldFByb2plY3RFc3RpbWF0ZXMiLCJ0b3RhbEVzdGltYXRlQW1vdW50IiwicmVkdWNlIiwic3VtIiwiZXN0aW1hdGUiLCJ0b3RhbCIsImdldFByb2plY3RzV2l0aEludm9pY2VUb3RhbHMiLCJpbnZvaWNlcyIsImdldEludm9pY2VzIiwicHJvamVjdHNXaXRoSW52b2ljZVRvdGFscyIsInByb2plY3RJbnZvaWNlcyIsImludm9pY2UiLCJ0b3RhbEludm9pY2VBbW91bnQiLCJhbW91bnQiLCJpbnZvaWNlX2lkIiwiaW52b2ljZV9udW1iZXIiLCJkYXRlIiwiYmlsbGVkX2Ftb3VudCIsInVuYmlsbGVkX2Ftb3VudCIsImdldFByb2plY3RJbnZvaWNlcyIsInByb2plY3RJZCIsImdldFByb2plY3REZXRhaWxzIiwiZ2V0UHJvamVjdENvbnRyYWN0cyIsImNvbnRyYWN0cyIsImdldFByb2ZpdEFuZExvc3MiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZ2V0Q2FzaEZsb3ciLCJnZXRCYWxhbmNlU2hlZXQiLCJnZXRDaGFydE9mQWNjb3VudHMiLCJjaGFydG9mYWNjb3VudHMiLCJnZXRKb3VybmFsRW50cmllcyIsImpvdXJuYWxlbnRyaWVzIiwiZ2V0RmluYW5jaWFsTWV0cmljcyIsInBsRGF0YSIsImJzRGF0YSIsImNmRGF0YSIsInJldmVudWUiLCJleHBlbnNlcyIsImdyb3NzUHJvZml0IiwibmV0UHJvZml0Iiwib3BlcmF0aW5nX2V4cGVuc2VzIiwib3BlcmF0aW5nSW5jb21lIiwiY2FzaEZsb3ciLCJuZXRfY2FzaF9mbG93IiwiYWNjb3VudHNSZWNlaXZhYmxlIiwiY3VycmVudF9hc3NldHMiLCJhY2NvdW50c19yZWNlaXZhYmxlIiwiYWNjb3VudHNQYXlhYmxlIiwiY3VycmVudF9saWFiaWxpdGllcyIsImFjY291bnRzX3BheWFibGUiLCJjYXNoQmFsYW5jZSIsImNhc2hfYW5kX2JhbmsiLCJnZXRUb2tlblN0YXR1cyIsImhhc1Rva2VuIiwiZXhwaXJlc0luIiwiaXNFeHBpcmVkIiwiZ2V0QXV0b1JlZnJlc2hTdGF0dXMiLCJ0aW1lU2luY2VMYXN0UmVmcmVzaCIsIm5leHRSZWZyZXNoSW4iLCJtYXgiLCJpc0FjdGl2ZSIsImVuYWJsZUF1dG9SZWZyZXNoIiwiZGlzYWJsZUF1dG9SZWZyZXNoIiwiZ2V0U3RhdHVzIiwiYXV0b1JlZnJlc2giLCJjb25zdHJ1Y3RvciIsInpvaG9TZXJ2aWNlIiwiZmV0Y2hQcm9qZWN0cyIsImZldGNoIiwicmVzdWx0IiwianNvbiIsInN1Y2Nlc3MiLCJjb3VudCIsImZldGNoSW52b2ljZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/zoho.ts\n"));

/***/ })

});