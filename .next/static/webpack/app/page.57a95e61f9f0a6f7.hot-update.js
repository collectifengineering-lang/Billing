"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/csvUtils.ts":
/*!*************************!*\
  !*** ./lib/csvUtils.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadCSV: function() { return /* binding */ downloadCSV; },\n/* harmony export */   exportProjectionsToCSV: function() { return /* binding */ exportProjectionsToCSV; },\n/* harmony export */   generateCSVFilename: function() { return /* binding */ generateCSVFilename; },\n/* harmony export */   importProjectionsFromCSV: function() { return /* binding */ importProjectionsFromCSV; },\n/* harmony export */   readCSVFile: function() { return /* binding */ readCSVFile; }\n/* harmony export */ });\n/**\r\n * Export projections table to CSV format\r\n */ function exportProjectionsToCSV(billingData, monthlyProjections, asrFees, signedFees, monthRange) {\n    // Create CSV header\n    const headers = [\n        \"Project ID\",\n        \"Project Name\",\n        \"Customer Name\",\n        \"Signed Fee\",\n        \"ASR Fee\",\n        ...monthRange.map((month)=>formatMonthForCSV(month))\n    ];\n    // Create CSV rows\n    const rows = billingData.map((project)=>{\n        const row = {\n            projectId: project.projectId,\n            projectName: project.projectName,\n            customerName: project.customerName,\n            signedFee: signedFees[project.projectId] || project.signedFee || 0,\n            asrFee: asrFees[project.projectId] || 0\n        };\n        // Add monthly projections\n        monthRange.forEach((month)=>{\n            var _monthlyProjections_project_projectId;\n            const value = ((_monthlyProjections_project_projectId = monthlyProjections[project.projectId]) === null || _monthlyProjections_project_projectId === void 0 ? void 0 : _monthlyProjections_project_projectId[month]) || 0;\n            row[month] = value;\n        });\n        return row;\n    });\n    // Convert to CSV format\n    const csvContent = [\n        headers.join(\",\"),\n        ...rows.map((row)=>headers.map((header)=>{\n                let value;\n                if (header === \"Project ID\") {\n                    // Ensure Project ID is always treated as a string to prevent scientific notation\n                    const projectId = row.projectId;\n                    console.log(\"CSV Export - Project ID type:\", typeof projectId, \"value:\", projectId);\n                    // Fix: Avoid using toLocaleString on 'never' type, ensure projectId is string or number\n                    if (typeof projectId === \"number\") {\n                        // Convert number to string without scientific notation\n                        value = projectId.toString();\n                    } else {\n                        // Use as string\n                        value = String(projectId);\n                    }\n                    console.log(\"CSV Export - Final Project ID value:\", value);\n                } else if (header === \"Project Name\") {\n                    value = row.projectName;\n                } else if (header === \"Customer Name\") {\n                    value = row.customerName;\n                } else if (header === \"Signed Fee\") {\n                    value = row.signedFee;\n                } else if (header === \"ASR Fee\") {\n                    value = row.asrFee;\n                } else {\n                    // For month columns, find the corresponding month in the original format\n                    const monthKey = monthRange.find((month)=>formatMonthForCSV(month) === header);\n                    value = monthKey ? row[monthKey] : 0;\n                }\n                // Escape commas and quotes in the value\n                const escapedValue = String(value).replace(/\"/g, '\"\"');\n                return '\"'.concat(escapedValue, '\"');\n            }).join(\",\"))\n    ].join(\"\\n\");\n    return csvContent;\n}\n/**\r\n * Import projections from CSV format\r\n */ function importProjectionsFromCSV(csvContent, billingData) {\n    try {\n        const lines = csvContent.trim().split(\"\\n\");\n        if (lines.length < 2) {\n            return {\n                success: false,\n                errors: [\n                    \"CSV file must have at least a header row and one data row\"\n                ]\n            };\n        }\n        const headers = parseCSVRow(lines[0]);\n        const dataRows = lines.slice(1);\n        // Validate headers\n        const requiredHeaders = [\n            \"Project ID\",\n            \"Project Name\",\n            \"Customer Name\",\n            \"Signed Fee\",\n            \"ASR Fee\"\n        ];\n        const missingHeaders = requiredHeaders.filter((header)=>!headers.includes(header));\n        if (missingHeaders.length > 0) {\n            return {\n                success: false,\n                errors: [\n                    \"Missing required headers: \".concat(missingHeaders.join(\", \"))\n                ]\n            };\n        }\n        // Extract month columns (everything after the required headers)\n        const monthColumns = headers.slice(5);\n        // Validate month format\n        const invalidMonths = monthColumns.filter((month)=>!/^\\d{4}-\\d{2}$/.test(month));\n        if (invalidMonths.length > 0) {\n            return {\n                success: false,\n                errors: [\n                    \"Invalid month format found: \".concat(invalidMonths.join(\", \"), \". Expected format: YYYY-MM\")\n                ]\n            };\n        }\n        const importedData = {};\n        const errors = [];\n        dataRows.forEach((row, index)=>{\n            const values = parseCSVRow(row);\n            if (values.length !== headers.length) {\n                errors.push(\"Row \".concat(index + 2, \": Column count mismatch. Expected \").concat(headers.length, \", got \").concat(values.length));\n                return;\n            }\n            const projectId = values[0].trim(); // Ensure it's treated as a string\n            const projectName = values[1];\n            const customerName = values[2];\n            const signedFee = parseFloat(values[3]) || 0;\n            const asrFee = parseFloat(values[4]) || 0;\n            // Validate project exists in billing data\n            const projectExists = billingData.some((p)=>p.projectId === projectId);\n            if (!projectExists) {\n                errors.push(\"Row \".concat(index + 2, ': Project ID \"').concat(projectId, '\" not found in current data'));\n                return;\n            }\n            // Parse monthly projections\n            const monthlyData = {};\n            monthColumns.forEach((month, monthIndex)=>{\n                const value = parseFloat(values[5 + monthIndex]) || 0;\n                monthlyData[month] = value;\n            });\n            importedData[projectId] = monthlyData;\n        });\n        if (errors.length > 0) {\n            return {\n                success: false,\n                errors,\n                data: importedData // Return partial data even with errors\n            };\n        }\n        return {\n            success: true,\n            data: importedData,\n            message: \"Successfully imported \".concat(Object.keys(importedData).length, \" projects with \").concat(monthColumns.length, \" months of data\")\n        };\n    } catch (error) {\n        return {\n            success: false,\n            errors: [\n                \"Error parsing CSV: \".concat(error instanceof Error ? error.message : \"Unknown error\")\n            ]\n        };\n    }\n}\n/**\r\n * Parse a CSV row, handling quoted values and commas\r\n */ function parseCSVRow(row) {\n    const values = [];\n    let current = \"\";\n    let inQuotes = false;\n    for(let i = 0; i < row.length; i++){\n        const char = row[i];\n        if (char === '\"') {\n            if (inQuotes && row[i + 1] === '\"') {\n                // Escaped quote\n                current += '\"';\n                i++; // Skip next quote\n            } else {\n                // Toggle quote state\n                inQuotes = !inQuotes;\n            }\n        } else if (char === \",\" && !inQuotes) {\n            // End of value\n            values.push(current.trim());\n            current = \"\";\n        } else {\n            current += char;\n        }\n    }\n    // Add the last value\n    values.push(current.trim());\n    return values;\n}\n/**\r\n * Format month for CSV display (e.g., \"2024-01\" -> \"Jan 2024\")\r\n */ function formatMonthForCSV(month) {\n    const [year, monthNum] = month.split(\"-\");\n    const date = new Date(parseInt(year), parseInt(monthNum) - 1);\n    return date.toLocaleDateString(\"en-US\", {\n        month: \"short\",\n        year: \"numeric\"\n    });\n}\n/**\r\n * Generate a filename for the CSV export\r\n */ function generateCSVFilename() {\n    const now = new Date();\n    const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD\n    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, \"-\"); // HH-MM-SS\n    return \"projections-export-\".concat(dateStr, \"-\").concat(timeStr, \".csv\");\n}\n/**\r\n * Download CSV content as a file\r\n */ function downloadCSV(csvContent, filename) {\n    const blob = new Blob([\n        csvContent\n    ], {\n        type: \"text/csv;charset=utf-8;\"\n    });\n    const link = document.createElement(\"a\");\n    if (link.download !== undefined) {\n        const url = URL.createObjectURL(blob);\n        link.setAttribute(\"href\", url);\n        link.setAttribute(\"download\", filename);\n        link.style.visibility = \"hidden\";\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n}\n/**\r\n * Read CSV file from input element\r\n */ function readCSVFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            var _event_target;\n            const content = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result;\n            resolve(content);\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Failed to read CSV file\"));\n        };\n        reader.readAsText(file);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dGlscy50cz8yMjY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpbGxpbmdEYXRhIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENTVlByb2plY3Rpb25EYXRhIHtcclxuICBwcm9qZWN0SWQ6IHN0cmluZztcclxuICBwcm9qZWN0TmFtZTogc3RyaW5nO1xyXG4gIGN1c3RvbWVyTmFtZTogc3RyaW5nO1xyXG4gIHNpZ25lZEZlZTogbnVtYmVyO1xyXG4gIGFzckZlZTogbnVtYmVyO1xyXG4gIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlcjsgLy8gRm9yIGR5bmFtaWMgbW9udGggY29sdW1uc1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENTVkltcG9ydFJlc3VsdCB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgbnVtYmVyPj47XHJcbiAgZXJyb3JzPzogc3RyaW5nW107XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9ydCBwcm9qZWN0aW9ucyB0YWJsZSB0byBDU1YgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0UHJvamVjdGlvbnNUb0NTVihcclxuICBiaWxsaW5nRGF0YTogQmlsbGluZ0RhdGFbXSxcclxuICBtb250aGx5UHJvamVjdGlvbnM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+LFxyXG4gIGFzckZlZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXHJcbiAgc2lnbmVkRmVlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcclxuICBtb250aFJhbmdlOiBzdHJpbmdbXVxyXG4pOiBzdHJpbmcge1xyXG5cclxuICAvLyBDcmVhdGUgQ1NWIGhlYWRlclxyXG4gIGNvbnN0IGhlYWRlcnMgPSBbXHJcbiAgICAnUHJvamVjdCBJRCcsXHJcbiAgICAnUHJvamVjdCBOYW1lJywgXHJcbiAgICAnQ3VzdG9tZXIgTmFtZScsXHJcbiAgICAnU2lnbmVkIEZlZScsXHJcbiAgICAnQVNSIEZlZScsXHJcbiAgICAuLi5tb250aFJhbmdlLm1hcChtb250aCA9PiBmb3JtYXRNb250aEZvckNTVihtb250aCkpXHJcbiAgXTtcclxuXHJcbiAgLy8gQ3JlYXRlIENTViByb3dzXHJcbiAgY29uc3Qgcm93cyA9IGJpbGxpbmdEYXRhLm1hcChwcm9qZWN0ID0+IHtcclxuICAgIGNvbnN0IHJvdzogQ1NWUHJvamVjdGlvbkRhdGEgPSB7XHJcbiAgICAgIHByb2plY3RJZDogcHJvamVjdC5wcm9qZWN0SWQsXHJcbiAgICAgIHByb2plY3ROYW1lOiBwcm9qZWN0LnByb2plY3ROYW1lLFxyXG4gICAgICBjdXN0b21lck5hbWU6IHByb2plY3QuY3VzdG9tZXJOYW1lLFxyXG4gICAgICBzaWduZWRGZWU6IHNpZ25lZEZlZXNbcHJvamVjdC5wcm9qZWN0SWRdIHx8IHByb2plY3Quc2lnbmVkRmVlIHx8IDAsXHJcbiAgICAgIGFzckZlZTogYXNyRmVlc1twcm9qZWN0LnByb2plY3RJZF0gfHwgMCxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIG1vbnRobHkgcHJvamVjdGlvbnNcclxuICAgIG1vbnRoUmFuZ2UuZm9yRWFjaChtb250aCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gbW9udGhseVByb2plY3Rpb25zW3Byb2plY3QucHJvamVjdElkXT8uW21vbnRoXSB8fCAwO1xyXG4gICAgICByb3dbbW9udGhdID0gdmFsdWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcm93O1xyXG4gIH0pO1xyXG5cclxuICAvLyBDb252ZXJ0IHRvIENTViBmb3JtYXRcclxuICBjb25zdCBjc3ZDb250ZW50ID0gW1xyXG4gICAgaGVhZGVycy5qb2luKCcsJyksXHJcbiAgICAuLi5yb3dzLm1hcChyb3cgPT4gXHJcbiAgICAgICAgICAgICBoZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xyXG4gICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgIGlmIChoZWFkZXIgPT09ICdQcm9qZWN0IElEJykge1xyXG4gICAgICAgICAgIC8vIEVuc3VyZSBQcm9qZWN0IElEIGlzIGFsd2F5cyB0cmVhdGVkIGFzIGEgc3RyaW5nIHRvIHByZXZlbnQgc2NpZW50aWZpYyBub3RhdGlvblxyXG4gICAgICAgICAgIGNvbnN0IHByb2plY3RJZCA9IHJvdy5wcm9qZWN0SWQ7XHJcbiAgICAgICAgICAgY29uc29sZS5sb2coJ0NTViBFeHBvcnQgLSBQcm9qZWN0IElEIHR5cGU6JywgdHlwZW9mIHByb2plY3RJZCwgJ3ZhbHVlOicsIHByb2plY3RJZCk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgLy8gRml4OiBBdm9pZCB1c2luZyB0b0xvY2FsZVN0cmluZyBvbiAnbmV2ZXInIHR5cGUsIGVuc3VyZSBwcm9qZWN0SWQgaXMgc3RyaW5nIG9yIG51bWJlclxyXG4gICAgICAgICAgIGlmICh0eXBlb2YgcHJvamVjdElkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXIgdG8gc3RyaW5nIHdpdGhvdXQgc2NpZW50aWZpYyBub3RhdGlvblxyXG4gICAgICAgICAgICAgdmFsdWUgPSBwcm9qZWN0SWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgLy8gVXNlIGFzIHN0cmluZ1xyXG4gICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcocHJvamVjdElkKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgY29uc29sZS5sb2coJ0NTViBFeHBvcnQgLSBGaW5hbCBQcm9qZWN0IElEIHZhbHVlOicsIHZhbHVlKTtcclxuICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIgPT09ICdQcm9qZWN0IE5hbWUnKSB7XHJcbiAgICAgICAgICAgdmFsdWUgPSByb3cucHJvamVjdE5hbWU7XHJcbiAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnQ3VzdG9tZXIgTmFtZScpIHtcclxuICAgICAgICAgICB2YWx1ZSA9IHJvdy5jdXN0b21lck5hbWU7XHJcbiAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnU2lnbmVkIEZlZScpIHtcclxuICAgICAgICAgICB2YWx1ZSA9IHJvdy5zaWduZWRGZWU7XHJcbiAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnQVNSIEZlZScpIHtcclxuICAgICAgICAgICB2YWx1ZSA9IHJvdy5hc3JGZWU7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgLy8gRm9yIG1vbnRoIGNvbHVtbnMsIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgbW9udGggaW4gdGhlIG9yaWdpbmFsIGZvcm1hdFxyXG4gICAgICAgICAgIGNvbnN0IG1vbnRoS2V5ID0gbW9udGhSYW5nZS5maW5kKG1vbnRoID0+IGZvcm1hdE1vbnRoRm9yQ1NWKG1vbnRoKSA9PT0gaGVhZGVyKTtcclxuICAgICAgICAgICB2YWx1ZSA9IG1vbnRoS2V5ID8gcm93W21vbnRoS2V5XSA6IDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgLy8gRXNjYXBlIGNvbW1hcyBhbmQgcXVvdGVzIGluIHRoZSB2YWx1ZVxyXG4gICAgICAgICBjb25zdCBlc2NhcGVkVmFsdWUgPSBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1wiL2csICdcIlwiJyk7XHJcbiAgICAgICAgIHJldHVybiBgXCIke2VzY2FwZWRWYWx1ZX1cImA7XHJcbiAgICAgICB9KS5qb2luKCcsJylcclxuICAgIClcclxuICBdLmpvaW4oJ1xcbicpO1xyXG5cclxuICByZXR1cm4gY3N2Q29udGVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEltcG9ydCBwcm9qZWN0aW9ucyBmcm9tIENTViBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbXBvcnRQcm9qZWN0aW9uc0Zyb21DU1YoXHJcbiAgY3N2Q29udGVudDogc3RyaW5nLFxyXG4gIGJpbGxpbmdEYXRhOiBCaWxsaW5nRGF0YVtdXHJcbik6IENTVkltcG9ydFJlc3VsdCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGxpbmVzID0gY3N2Q29udGVudC50cmltKCkuc3BsaXQoJ1xcbicpO1xyXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcnM6IFsnQ1NWIGZpbGUgbXVzdCBoYXZlIGF0IGxlYXN0IGEgaGVhZGVyIHJvdyBhbmQgb25lIGRhdGEgcm93J11cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VDU1ZSb3cobGluZXNbMF0pO1xyXG4gICAgY29uc3QgZGF0YVJvd3MgPSBsaW5lcy5zbGljZSgxKTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBoZWFkZXJzXHJcbiAgICBjb25zdCByZXF1aXJlZEhlYWRlcnMgPSBbJ1Byb2plY3QgSUQnLCAnUHJvamVjdCBOYW1lJywgJ0N1c3RvbWVyIE5hbWUnLCAnU2lnbmVkIEZlZScsICdBU1IgRmVlJ107XHJcbiAgICBjb25zdCBtaXNzaW5nSGVhZGVycyA9IHJlcXVpcmVkSGVhZGVycy5maWx0ZXIoaGVhZGVyID0+ICFoZWFkZXJzLmluY2x1ZGVzKGhlYWRlcikpO1xyXG4gICAgXHJcbiAgICBpZiAobWlzc2luZ0hlYWRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yczogW2BNaXNzaW5nIHJlcXVpcmVkIGhlYWRlcnM6ICR7bWlzc2luZ0hlYWRlcnMuam9pbignLCAnKX1gXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3QgbW9udGggY29sdW1ucyAoZXZlcnl0aGluZyBhZnRlciB0aGUgcmVxdWlyZWQgaGVhZGVycylcclxuICAgIGNvbnN0IG1vbnRoQ29sdW1ucyA9IGhlYWRlcnMuc2xpY2UoNSk7XHJcbiAgICBcclxuICAgIC8vIFZhbGlkYXRlIG1vbnRoIGZvcm1hdFxyXG4gICAgY29uc3QgaW52YWxpZE1vbnRocyA9IG1vbnRoQ29sdW1ucy5maWx0ZXIobW9udGggPT4gIS9eXFxkezR9LVxcZHsyfSQvLnRlc3QobW9udGgpKTtcclxuICAgIGlmIChpbnZhbGlkTW9udGhzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcnM6IFtgSW52YWxpZCBtb250aCBmb3JtYXQgZm91bmQ6ICR7aW52YWxpZE1vbnRocy5qb2luKCcsICcpfS4gRXhwZWN0ZWQgZm9ybWF0OiBZWVlZLU1NYF1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbXBvcnRlZERhdGE6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+ID0ge307XHJcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgZGF0YVJvd3MuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSBwYXJzZUNTVlJvdyhyb3cpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGhlYWRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IENvbHVtbiBjb3VudCBtaXNtYXRjaC4gRXhwZWN0ZWQgJHtoZWFkZXJzLmxlbmd0aH0sIGdvdCAke3ZhbHVlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAgICAgICAgY29uc3QgcHJvamVjdElkID0gdmFsdWVzWzBdLnRyaW0oKTsgLy8gRW5zdXJlIGl0J3MgdHJlYXRlZCBhcyBhIHN0cmluZ1xyXG4gICAgICAgY29uc3QgcHJvamVjdE5hbWUgPSB2YWx1ZXNbMV07XHJcbiAgICAgICBjb25zdCBjdXN0b21lck5hbWUgPSB2YWx1ZXNbMl07XHJcbiAgICAgICBjb25zdCBzaWduZWRGZWUgPSBwYXJzZUZsb2F0KHZhbHVlc1szXSkgfHwgMDtcclxuICAgICAgIGNvbnN0IGFzckZlZSA9IHBhcnNlRmxvYXQodmFsdWVzWzRdKSB8fCAwO1xyXG5cclxuICAgICAgLy8gVmFsaWRhdGUgcHJvamVjdCBleGlzdHMgaW4gYmlsbGluZyBkYXRhXHJcbiAgICAgIGNvbnN0IHByb2plY3RFeGlzdHMgPSBiaWxsaW5nRGF0YS5zb21lKHAgPT4gcC5wcm9qZWN0SWQgPT09IHByb2plY3RJZCk7XHJcbiAgICAgIGlmICghcHJvamVjdEV4aXN0cykge1xyXG4gICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBQcm9qZWN0IElEIFwiJHtwcm9qZWN0SWR9XCIgbm90IGZvdW5kIGluIGN1cnJlbnQgZGF0YWApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUGFyc2UgbW9udGhseSBwcm9qZWN0aW9uc1xyXG4gICAgICBjb25zdCBtb250aGx5RGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gICAgICBtb250aENvbHVtbnMuZm9yRWFjaCgobW9udGgsIG1vbnRoSW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWVzWzUgKyBtb250aEluZGV4XSkgfHwgMDtcclxuICAgICAgICBtb250aGx5RGF0YVttb250aF0gPSB2YWx1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpbXBvcnRlZERhdGFbcHJvamVjdElkXSA9IG1vbnRobHlEYXRhO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3JzLFxyXG4gICAgICAgIGRhdGE6IGltcG9ydGVkRGF0YSAvLyBSZXR1cm4gcGFydGlhbCBkYXRhIGV2ZW4gd2l0aCBlcnJvcnNcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBkYXRhOiBpbXBvcnRlZERhdGEsXHJcbiAgICAgIG1lc3NhZ2U6IGBTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgJHtPYmplY3Qua2V5cyhpbXBvcnRlZERhdGEpLmxlbmd0aH0gcHJvamVjdHMgd2l0aCAke21vbnRoQ29sdW1ucy5sZW5ndGh9IG1vbnRocyBvZiBkYXRhYFxyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcnM6IFtgRXJyb3IgcGFyc2luZyBDU1Y6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YF1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgYSBDU1Ygcm93LCBoYW5kbGluZyBxdW90ZWQgdmFsdWVzIGFuZCBjb21tYXNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlQ1NWUm93KHJvdzogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSBbXTtcclxuICBsZXQgY3VycmVudCA9ICcnO1xyXG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjaGFyID0gcm93W2ldO1xyXG4gICAgXHJcbiAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xyXG4gICAgICBpZiAoaW5RdW90ZXMgJiYgcm93W2kgKyAxXSA9PT0gJ1wiJykge1xyXG4gICAgICAgIC8vIEVzY2FwZWQgcXVvdGVcclxuICAgICAgICBjdXJyZW50ICs9ICdcIic7XHJcbiAgICAgICAgaSsrOyAvLyBTa2lwIG5leHQgcXVvdGVcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUb2dnbGUgcXVvdGUgc3RhdGVcclxuICAgICAgICBpblF1b3RlcyA9ICFpblF1b3RlcztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XHJcbiAgICAgIC8vIEVuZCBvZiB2YWx1ZVxyXG4gICAgICB2YWx1ZXMucHVzaChjdXJyZW50LnRyaW0oKSk7XHJcbiAgICAgIGN1cnJlbnQgPSAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJlbnQgKz0gY2hhcjtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIHRoZSBsYXN0IHZhbHVlXHJcbiAgdmFsdWVzLnB1c2goY3VycmVudC50cmltKCkpO1xyXG4gIFxyXG4gIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgbW9udGggZm9yIENTViBkaXNwbGF5IChlLmcuLCBcIjIwMjQtMDFcIiAtPiBcIkphbiAyMDI0XCIpXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRNb250aEZvckNTVihtb250aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBbeWVhciwgbW9udGhOdW1dID0gbW9udGguc3BsaXQoJy0nKTtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUocGFyc2VJbnQoeWVhciksIHBhcnNlSW50KG1vbnRoTnVtKSAtIDEpO1xyXG4gIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IG1vbnRoOiAnc2hvcnQnLCB5ZWFyOiAnbnVtZXJpYycgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGZpbGVuYW1lIGZvciB0aGUgQ1NWIGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ1NWRmlsZW5hbWUoKTogc3RyaW5nIHtcclxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gIGNvbnN0IGRhdGVTdHIgPSBub3cudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCk7IC8vIFlZWVktTU0tRERcclxuICBjb25zdCB0aW1lU3RyID0gbm93LnRvVGltZVN0cmluZygpLnNsaWNlKDAsIDgpLnJlcGxhY2UoLzovZywgJy0nKTsgLy8gSEgtTU0tU1NcclxuICByZXR1cm4gYHByb2plY3Rpb25zLWV4cG9ydC0ke2RhdGVTdHJ9LSR7dGltZVN0cn0uY3N2YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERvd25sb2FkIENTViBjb250ZW50IGFzIGEgZmlsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkQ1NWKGNzdkNvbnRlbnQ6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7JyB9KTtcclxuICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gIFxyXG4gIGlmIChsaW5rLmRvd25sb2FkICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XHJcbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBmaWxlbmFtZSk7XHJcbiAgICBsaW5rLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgICBsaW5rLmNsaWNrKCk7XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWQgQ1NWIGZpbGUgZnJvbSBpbnB1dCBlbGVtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVhZENTVkZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICBcclxuICAgIHJlYWRlci5vbmxvYWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGV2ZW50LnRhcmdldD8ucmVzdWx0IGFzIHN0cmluZztcclxuICAgICAgcmVzb2x2ZShjb250ZW50KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBDU1YgZmlsZScpKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gIH0pO1xyXG59ICJdLCJuYW1lcyI6WyJleHBvcnRQcm9qZWN0aW9uc1RvQ1NWIiwiYmlsbGluZ0RhdGEiLCJtb250aGx5UHJvamVjdGlvbnMiLCJhc3JGZWVzIiwic2lnbmVkRmVlcyIsIm1vbnRoUmFuZ2UiLCJoZWFkZXJzIiwibWFwIiwibW9udGgiLCJmb3JtYXRNb250aEZvckNTViIsInJvd3MiLCJwcm9qZWN0Iiwicm93IiwicHJvamVjdElkIiwicHJvamVjdE5hbWUiLCJjdXN0b21lck5hbWUiLCJzaWduZWRGZWUiLCJhc3JGZWUiLCJmb3JFYWNoIiwidmFsdWUiLCJjc3ZDb250ZW50Iiwiam9pbiIsImhlYWRlciIsImNvbnNvbGUiLCJsb2ciLCJ0b1N0cmluZyIsIlN0cmluZyIsIm1vbnRoS2V5IiwiZmluZCIsImVzY2FwZWRWYWx1ZSIsInJlcGxhY2UiLCJpbXBvcnRQcm9qZWN0aW9uc0Zyb21DU1YiLCJsaW5lcyIsInRyaW0iLCJzcGxpdCIsImxlbmd0aCIsInN1Y2Nlc3MiLCJlcnJvcnMiLCJwYXJzZUNTVlJvdyIsImRhdGFSb3dzIiwic2xpY2UiLCJyZXF1aXJlZEhlYWRlcnMiLCJtaXNzaW5nSGVhZGVycyIsImZpbHRlciIsImluY2x1ZGVzIiwibW9udGhDb2x1bW5zIiwiaW52YWxpZE1vbnRocyIsInRlc3QiLCJpbXBvcnRlZERhdGEiLCJpbmRleCIsInZhbHVlcyIsInB1c2giLCJwYXJzZUZsb2F0IiwicHJvamVjdEV4aXN0cyIsInNvbWUiLCJwIiwibW9udGhseURhdGEiLCJtb250aEluZGV4IiwiZGF0YSIsIm1lc3NhZ2UiLCJPYmplY3QiLCJrZXlzIiwiZXJyb3IiLCJFcnJvciIsImN1cnJlbnQiLCJpblF1b3RlcyIsImkiLCJjaGFyIiwieWVhciIsIm1vbnRoTnVtIiwiZGF0ZSIsIkRhdGUiLCJwYXJzZUludCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImdlbmVyYXRlQ1NWRmlsZW5hbWUiLCJub3ciLCJkYXRlU3RyIiwidG9JU09TdHJpbmciLCJ0aW1lU3RyIiwidG9UaW1lU3RyaW5nIiwiZG93bmxvYWRDU1YiLCJmaWxlbmFtZSIsImJsb2IiLCJCbG9iIiwidHlwZSIsImxpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkb3dubG9hZCIsInVuZGVmaW5lZCIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlQ2hpbGQiLCJyZWFkQ1NWRmlsZSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsImNvbnRlbnQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJvbmVycm9yIiwicmVhZEFzVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/csvUtils.ts\n"));

/***/ })

});