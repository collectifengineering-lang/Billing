"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/zoho.ts":
/*!*********************!*\
  !*** ./lib/zoho.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchInvoices: function() { return /* binding */ fetchInvoices; },\n/* harmony export */   fetchProjects: function() { return /* binding */ fetchProjects; },\n/* harmony export */   zohoService: function() { return /* binding */ zohoService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nclass ZohoService {\n    _startAutoRefresh() {\n        // Clear any existing timer\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n        }\n        // Set up automatic refresh every 45 minutes\n        this.autoRefreshTimer = setInterval(async ()=>{\n            try {\n                console.log(\"Auto-refreshing Zoho token (45-minute interval)...\");\n                this.lastRefreshTime = Date.now(); // Track when refresh was triggered\n                await this.forceRefreshToken();\n                console.log(\"Auto-refresh completed successfully\");\n            } catch (error) {\n                console.error(\"Auto-refresh failed:\", error);\n            }\n        }, this.AUTO_REFRESH_INTERVAL);\n        // Set initial refresh time\n        this.lastRefreshTime = Date.now();\n        console.log(\"Automatic Zoho token refresh started (every 45 minutes)\");\n    }\n    _stopAutoRefresh() {\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n            this.autoRefreshTimer = null;\n            console.log(\"Automatic Zoho token refresh stopped\");\n        }\n    }\n    async getAccessToken() {\n        // Check if token is still valid (with buffer)\n        if (this.accessToken && Date.now() < this.tokenExpiry - this.TOKEN_REFRESH_BUFFER) {\n            return this.accessToken;\n        }\n        // If there's already a refresh in progress, wait for it\n        if (this.refreshPromise) {\n            return this.refreshPromise;\n        }\n        // Start a new refresh\n        this.refreshPromise = this.refreshAccessToken();\n        try {\n            const token = await this.refreshPromise;\n            return token;\n        } finally{\n            this.refreshPromise = null;\n        }\n    }\n    async refreshAccessToken() {\n        try {\n            console.log(\"Refreshing Zoho access token...\");\n            // Create form data for the request\n            const formData = new URLSearchParams();\n            formData.append(\"refresh_token\", \"1000.4bf26c4881dfba83aae32546453d662d.a9353e91362a18c457b5cbec86b10ed2\" || 0);\n            formData.append(\"client_id\", \"1000.8RL8WMTDXS0WIP2EJF2XUS6NDSLQEP\" || 0);\n            formData.append(\"client_secret\", \"8a7ee3c04f0a0d860dd215c4449deab9bf15d1d00b\" || 0);\n            formData.append(\"grant_type\", \"refresh_token\");\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"https://accounts.zoho.com/oauth/v2/token\", formData, {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n            this.accessToken = response.data.access_token;\n            this.tokenExpiry = Date.now() + response.data.expires_in * 1000;\n            console.log(\"Token refreshed successfully. Expires in \".concat(Math.round(response.data.expires_in / 60), \" minutes\"));\n            return this.accessToken;\n        } catch (error) {\n            console.error(\"Error refreshing Zoho access token:\", error);\n            throw new Error(\"Failed to authenticate with Zoho\");\n        }\n    }\n    async makeRequest(endpoint) {\n        const token = await this.getAccessToken();\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://www.zohoapis.com/books/v3/\".concat(endpoint), {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(token),\n                    \"Content-Type\": \"application/json\"\n                },\n                params: {\n                    organization_id: \"652094923\"\n                }\n            });\n            return response.data;\n        } catch (error) {\n            var _error_response;\n            // If we get a 401, try refreshing the token once\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401) {\n                console.log(\"Token expired, refreshing...\");\n                this.accessToken = null;\n                this.tokenExpiry = 0;\n                const newToken = await this.getAccessToken();\n                // Retry the request with the new token\n                const retryResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://www.zohoapis.com/books/v3/\".concat(endpoint), {\n                    headers: {\n                        \"Authorization\": \"Bearer \".concat(newToken),\n                        \"Content-Type\": \"application/json\"\n                    },\n                    params: {\n                        organization_id: \"652094923\"\n                    }\n                });\n                return retryResponse.data;\n            }\n            console.error(\"Error making Zoho request to \".concat(endpoint, \":\"), error);\n            throw new Error(\"Failed to fetch data from Zoho: \".concat(endpoint));\n        }\n    }\n    async getProjects() {\n        try {\n            let allProjects = [];\n            let page = 1;\n            const perPage = 200;\n            while(true){\n                var _data_projects;\n                const data = await this.makeRequest(\"projects?page=\".concat(page, \"&per_page=\").concat(perPage));\n                const projects = ((_data_projects = data.projects) === null || _data_projects === void 0 ? void 0 : _data_projects.map((project)=>{\n                    // Log the first project to see available fields\n                    if (page === 1 && allProjects.length === 0) {\n                        console.log(\"Sample Zoho project data:\", JSON.stringify(project, null, 2));\n                    }\n                    return {\n                        project_id: project.project_id,\n                        project_name: project.project_name || project.name || \"\",\n                        description: project.description || \"\",\n                        status: project.status || \"active\",\n                        start_date: project.start_date || \"\",\n                        end_date: project.end_date || \"\",\n                        budget_amount: project.budget_amount || 0,\n                        rate_per_hour: project.rate_per_hour || 0,\n                        customer_id: project.customer_id || \"\",\n                        customer_name: project.customer_name || \"\",\n                        signed_fee: undefined\n                    };\n                })) || [];\n                allProjects = allProjects.concat(projects);\n                // Check if we've reached the end\n                if (projects.length < perPage) {\n                    break;\n                }\n                page++;\n            }\n            console.log(\"Fetched \".concat(allProjects.length, \" projects from Zoho\"));\n            return allProjects;\n        } catch (error) {\n            console.error(\"Error fetching projects:\", error);\n            return [];\n        }\n    }\n    async getProjectsWithRevenueBudget() {\n        try {\n            console.log(\"Fetching projects with revenue budget data...\");\n            const projects = await this.getProjects();\n            // Log projects that have revenue_budget data\n            const projectsWithRevenueBudget = projects.filter((project)=>{\n                const hasRevenueBudget = project.signed_fee && project.signed_fee > 0;\n                if (hasRevenueBudget) {\n                    console.log(\"Project \".concat(project.project_name, \" has revenue budget: $\").concat(project.signed_fee));\n                }\n                return hasRevenueBudget;\n            });\n            console.log(\"Found \".concat(projectsWithRevenueBudget.length, \" projects with revenue budget data\"));\n            return projects;\n        } catch (error) {\n            console.error(\"Error fetching projects with revenue budget:\", error);\n            return [];\n        }\n    }\n    async debugProjectFields() {\n        try {\n            console.log(\"Debugging Zoho project fields...\");\n            const data = await this.makeRequest(\"projects?page=1&per_page=5\");\n            if (data.projects && data.projects.length > 0) {\n                console.log(\"Available fields in Zoho project response:\");\n                const sampleProject = data.projects[0];\n                Object.keys(sampleProject).forEach((key)=>{\n                    console.log(\"  \".concat(key, \": \").concat(sampleProject[key], \" (\").concat(typeof sampleProject[key], \")\"));\n                });\n                // Check specifically for revenue_budget\n                if (sampleProject.revenue_budget !== undefined) {\n                    console.log(\"✅ Found revenue_budget field: \".concat(sampleProject.revenue_budget));\n                } else {\n                    console.log(\"❌ revenue_budget field not found in Zoho response\");\n                    console.log(\"Available budget-related fields:\");\n                    Object.keys(sampleProject).forEach((key)=>{\n                        if (key.toLowerCase().includes(\"budget\") || key.toLowerCase().includes(\"revenue\")) {\n                            console.log(\"  \".concat(key, \": \").concat(sampleProject[key]));\n                        }\n                    });\n                }\n            } else {\n                console.log(\"No projects found in Zoho response\");\n            }\n        } catch (error) {\n            console.error(\"Error debugging project fields:\", error);\n        }\n    }\n    async getProjectsWithEstimates() {\n        try {\n            const projects = await this.getProjects();\n            // For the first few projects, try to get estimates to see if that contains the signed fee\n            const projectsWithEstimates = await Promise.all(projects.slice(0, 5).map(async (project)=>{\n                try {\n                    const estimates = await this.getProjectEstimates(project.project_id);\n                    const totalEstimateAmount = estimates.reduce((sum, estimate)=>sum + (estimate.total || 0), 0);\n                    console.log(\"Project \".concat(project.project_name, \" estimates:\"), estimates.length, \"total amount:\", totalEstimateAmount);\n                    return {\n                        ...project,\n                        signed_fee: project.signed_fee || totalEstimateAmount || 0\n                    };\n                } catch (error) {\n                    console.error(\"Error fetching estimates for project \".concat(project.project_id, \":\"), error);\n                    return project;\n                }\n            }));\n            // Return all projects, with the first 5 having updated signed fees from estimates\n            return [\n                ...projectsWithEstimates,\n                ...projects.slice(5)\n            ];\n        } catch (error) {\n            console.error(\"Error fetching projects with estimates:\", error);\n            return [];\n        }\n    }\n    async getProjectsWithInvoiceTotals() {\n        try {\n            const [projects, invoices] = await Promise.all([\n                this.getProjects(),\n                this.getInvoices()\n            ]);\n            // Calculate signed fee as total of all invoices for each project\n            const projectsWithInvoiceTotals = projects.map((project)=>{\n                const projectInvoices = invoices.filter((invoice)=>invoice.project_id === project.project_id);\n                const totalInvoiceAmount = projectInvoices.reduce((sum, invoice)=>sum + invoice.amount, 0);\n                console.log(\"Project \".concat(project.project_name, \" invoices:\"), projectInvoices.length, \"total amount:\", totalInvoiceAmount);\n                return {\n                    ...project,\n                    signed_fee: project.signed_fee || totalInvoiceAmount || 0\n                };\n            });\n            return projectsWithInvoiceTotals;\n        } catch (error) {\n            console.error(\"Error fetching projects with invoice totals:\", error);\n            return [];\n        }\n    }\n    async getInvoices() {\n        try {\n            var _data_invoices;\n            const data = await this.makeRequest(\"invoices\");\n            return ((_data_invoices = data.invoices) === null || _data_invoices === void 0 ? void 0 : _data_invoices.map((invoice)=>({\n                    invoice_id: invoice.invoice_id,\n                    project_id: invoice.project_id,\n                    invoice_number: invoice.invoice_number,\n                    date: invoice.date,\n                    amount: invoice.total,\n                    status: invoice.status,\n                    billed_amount: invoice.billed_amount || 0,\n                    unbilled_amount: invoice.unbilled_amount || 0\n                }))) || [];\n        } catch (error) {\n            console.error(\"Error fetching invoices:\", error);\n            return [];\n        }\n    }\n    async getProjectInvoices(projectId) {\n        try {\n            var _data_invoices;\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/invoices\"));\n            return ((_data_invoices = data.invoices) === null || _data_invoices === void 0 ? void 0 : _data_invoices.map((invoice)=>({\n                    invoice_id: invoice.invoice_id,\n                    project_id: invoice.project_id,\n                    invoice_number: invoice.invoice_number,\n                    date: invoice.date,\n                    amount: invoice.total,\n                    status: invoice.status,\n                    billed_amount: invoice.billed_amount || 0,\n                    unbilled_amount: invoice.unbilled_amount || 0\n                }))) || [];\n        } catch (error) {\n            console.error(\"Error fetching project invoices:\", error);\n            return [];\n        }\n    }\n    async getProjectDetails(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId));\n            console.log(\"Project \".concat(projectId, \" details:\"), JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching project details:\", error);\n            return null;\n        }\n    }\n    async getProjectEstimates(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/estimates\"));\n            console.log(\"Project \".concat(projectId, \" estimates:\"), JSON.stringify(data, null, 2));\n            return data.estimates || [];\n        } catch (error) {\n            console.error(\"Error fetching project estimates:\", error);\n            return [];\n        }\n    }\n    async getProjectContracts(projectId) {\n        try {\n            const data = await this.makeRequest(\"projects/\".concat(projectId, \"/contracts\"));\n            console.log(\"Project \".concat(projectId, \" contracts:\"), JSON.stringify(data, null, 2));\n            return data.contracts || [];\n        } catch (error) {\n            console.error(\"Error fetching project contracts:\", error);\n            return [];\n        }\n    }\n    // New method to get Profit & Loss statement\n    async getProfitAndLoss(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"reports/profitandloss?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Profit & Loss data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Profit & Loss:\", error);\n            return null;\n        }\n    }\n    // New method to get Cash Flow statement\n    async getCashFlow(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"reports/cashflow?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Cash Flow data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Cash Flow:\", error);\n            return null;\n        }\n    }\n    // New method to get Balance Sheet\n    async getBalanceSheet(date) {\n        try {\n            const data = await this.makeRequest(\"reports/balancesheet?date=\".concat(date));\n            console.log(\"Balance Sheet data:\", JSON.stringify(data, null, 2));\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching Balance Sheet:\", error);\n            return null;\n        }\n    }\n    // New method to get Chart of Accounts\n    async getChartOfAccounts() {\n        try {\n            const data = await this.makeRequest(\"chartofaccounts\");\n            console.log(\"Chart of Accounts data:\", JSON.stringify(data, null, 2));\n            return data.chartofaccounts || [];\n        } catch (error) {\n            console.error(\"Error fetching Chart of Accounts:\", error);\n            return [];\n        }\n    }\n    // New method to get Journal Entries for a date range\n    async getJournalEntries(startDate, endDate) {\n        try {\n            const data = await this.makeRequest(\"journalentries?from_date=\".concat(startDate, \"&to_date=\").concat(endDate));\n            console.log(\"Journal Entries data:\", JSON.stringify(data, null, 2));\n            return data.journalentries || [];\n        } catch (error) {\n            console.error(\"Error fetching Journal Entries:\", error);\n            return [];\n        }\n    }\n    // New method to get comprehensive financial metrics\n    async getFinancialMetrics(startDate, endDate) {\n        try {\n            var _plData_revenue, _plData_expenses, _plData_operating_expenses, _plData_operating_expenses1, _bsData_current_assets, _bsData_current_liabilities, _bsData_current_assets1;\n            const [plData, cfData, bsData] = await Promise.all([\n                this.getProfitAndLoss(startDate, endDate),\n                this.getCashFlow(startDate, endDate),\n                this.getBalanceSheet(endDate)\n            ]);\n            // Extract financial metrics from the responses\n            const revenue = (plData === null || plData === void 0 ? void 0 : (_plData_revenue = plData.revenue) === null || _plData_revenue === void 0 ? void 0 : _plData_revenue.total) || 0;\n            const expenses = (plData === null || plData === void 0 ? void 0 : (_plData_expenses = plData.expenses) === null || _plData_expenses === void 0 ? void 0 : _plData_expenses.total) || 0;\n            const grossProfit = revenue - expenses;\n            // Calculate net profit (may need adjustment based on actual Zoho response structure)\n            const netProfit = grossProfit - ((plData === null || plData === void 0 ? void 0 : (_plData_operating_expenses = plData.operating_expenses) === null || _plData_operating_expenses === void 0 ? void 0 : _plData_operating_expenses.total) || 0);\n            const operatingIncome = grossProfit - ((plData === null || plData === void 0 ? void 0 : (_plData_operating_expenses1 = plData.operating_expenses) === null || _plData_operating_expenses1 === void 0 ? void 0 : _plData_operating_expenses1.total) || 0);\n            // Extract cash flow data\n            const cashFlow = (cfData === null || cfData === void 0 ? void 0 : cfData.net_cash_flow) || 0;\n            const accountsReceivable = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_assets = bsData.current_assets) === null || _bsData_current_assets === void 0 ? void 0 : _bsData_current_assets.accounts_receivable) || 0;\n            const accountsPayable = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_liabilities = bsData.current_liabilities) === null || _bsData_current_liabilities === void 0 ? void 0 : _bsData_current_liabilities.accounts_payable) || 0;\n            const cashBalance = (bsData === null || bsData === void 0 ? void 0 : (_bsData_current_assets1 = bsData.current_assets) === null || _bsData_current_assets1 === void 0 ? void 0 : _bsData_current_assets1.cash_and_bank) || 0;\n            return {\n                revenue,\n                expenses,\n                grossProfit,\n                netProfit,\n                operatingIncome,\n                cashFlow,\n                accountsReceivable,\n                accountsPayable,\n                cashBalance\n            };\n        } catch (error) {\n            console.error(\"Error fetching financial metrics:\", error);\n            // Return default values if API calls fail\n            return {\n                revenue: 0,\n                expenses: 0,\n                grossProfit: 0,\n                netProfit: 0,\n                operatingIncome: 0,\n                cashFlow: 0,\n                accountsReceivable: 0,\n                accountsPayable: 0,\n                cashBalance: 0\n            };\n        }\n    }\n    // Method to manually refresh token (for testing)\n    async forceRefreshToken() {\n        this.accessToken = null;\n        this.tokenExpiry = 0;\n        this.lastRefreshTime = Date.now(); // Track manual refresh time\n        await this.getAccessToken();\n    }\n    // Get token status for debugging\n    getTokenStatus() {\n        const now = Date.now();\n        return {\n            hasToken: !!this.accessToken,\n            expiresIn: this.tokenExpiry - now,\n            isExpired: now >= this.tokenExpiry\n        };\n    }\n    // Method to get auto-refresh status\n    getAutoRefreshStatus() {\n        const now = Date.now();\n        const timeSinceLastRefresh = now - this.lastRefreshTime;\n        const nextRefreshIn = Math.max(0, this.AUTO_REFRESH_INTERVAL - timeSinceLastRefresh);\n        return {\n            isActive: !!this.autoRefreshTimer,\n            nextRefreshIn\n        };\n    }\n    // Public method to start auto-refresh\n    enableAutoRefresh() {\n        this._startAutoRefresh();\n    }\n    // Public method to stop auto-refresh\n    disableAutoRefresh() {\n        this._stopAutoRefresh();\n    }\n    // Public method to get comprehensive status\n    getStatus() {\n        return {\n            ...this.getTokenStatus(),\n            autoRefresh: this.getAutoRefreshStatus()\n        };\n    }\n    constructor(){\n        this.accessToken = null;\n        this.tokenExpiry = 0;\n        this.refreshPromise = null;\n        this.TOKEN_REFRESH_BUFFER = 5 * 60 * 1000 // 5 minutes buffer\n        ;\n        this.autoRefreshTimer = null;\n        this.AUTO_REFRESH_INTERVAL = 45 * 60 * 1000 // 45 minutes\n        ;\n        this.lastRefreshTime = 0 // Track when auto-refresh was last triggered\n        ;\n        // Start automatic token refresh\n        this._startAutoRefresh();\n    }\n}\nconst zohoService = new ZohoService();\n// Export the functions that are being imported in page.tsx\nconst fetchProjects = async ()=>{\n    try {\n        console.log(\"Client: Fetching projects from API\");\n        const response = await fetch(\"/api/projects\");\n        const result = await response.json();\n        if (result.success) {\n            console.log(\"Client: Successfully fetched\", result.count, \"projects\");\n            return result.data;\n        } else {\n            console.error(\"Client: API returned error:\", result.error);\n            throw new Error(result.error);\n        }\n    } catch (error) {\n        console.error(\"Client: Error fetching projects:\", error);\n        throw error;\n    }\n};\nconst fetchInvoices = async ()=>{\n    try {\n        console.log(\"Client: Fetching invoices from API\");\n        const response = await fetch(\"/api/invoices\");\n        const result = await response.json();\n        if (result.success) {\n            console.log(\"Client: Successfully fetched\", result.count, \"invoices\");\n            return result.data;\n        } else {\n            console.error(\"Client: API returned error:\", result.error);\n            throw new Error(result.error);\n        }\n    } catch (error) {\n        console.error(\"Client: Error fetching invoices:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ0wzQixRQUFRTSxLQUFLLENBQUMsK0JBQStCb0osT0FBT3BKLEtBQUs7WUFDekQsTUFBTSxJQUFJMEIsTUFBTTBILE9BQU9wSixLQUFLO1FBQzlCO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2ROLFFBQVFNLEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE1BQU1BO0lBQ1I7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi96b2hvLnRzP2U3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9ob1Byb2plY3Qge1xyXG4gIHByb2plY3RfaWQ6IHN0cmluZztcclxuICBwcm9qZWN0X25hbWU6IHN0cmluZzsgLy8gQ2hhbmdlZCBmcm9tIG5hbWUgdG8gcHJvamVjdF9uYW1lXHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbiAgc3RhdHVzOiBzdHJpbmc7XHJcbiAgc3RhcnRfZGF0ZTogc3RyaW5nO1xyXG4gIGVuZF9kYXRlPzogc3RyaW5nO1xyXG4gIGJ1ZGdldF9hbW91bnQ/OiBudW1iZXI7XHJcbiAgcmF0ZV9wZXJfaG91cj86IG51bWJlcjtcclxuICBjdXN0b21lcl9pZDogc3RyaW5nO1xyXG4gIGN1c3RvbWVyX25hbWU6IHN0cmluZztcclxuICBzaWduZWRfZmVlPzogbnVtYmVyOyAvLyBBZGRlZCBmb3IgU2lnbmVkIEZlZSBmcm9tIFpvaG9cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBab2hvSW52b2ljZSB7XHJcbiAgaW52b2ljZV9pZDogc3RyaW5nO1xyXG4gIHByb2plY3RfaWQ6IHN0cmluZztcclxuICBpbnZvaWNlX251bWJlcjogc3RyaW5nO1xyXG4gIGRhdGU6IHN0cmluZztcclxuICBhbW91bnQ6IG51bWJlcjtcclxuICBzdGF0dXM6IHN0cmluZztcclxuICBiaWxsZWRfYW1vdW50OiBudW1iZXI7XHJcbiAgdW5iaWxsZWRfYW1vdW50OiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUb2tlblJlc3BvbnNlIHtcclxuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcclxuICBleHBpcmVzX2luOiBudW1iZXI7XHJcbiAgYXBpX2RvbWFpbjogc3RyaW5nO1xyXG4gIHRva2VuX3R5cGU6IHN0cmluZztcclxuICByZWZyZXNoX3Rva2VuPzogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBab2hvU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSB0b2tlbkV4cGlyeTogbnVtYmVyID0gMDtcclxuICBwcml2YXRlIHJlZnJlc2hQcm9taXNlOiBQcm9taXNlPHN0cmluZz4gfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IFRPS0VOX1JFRlJFU0hfQlVGRkVSID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzIGJ1ZmZlclxyXG4gIHByaXZhdGUgYXV0b1JlZnJlc2hUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IEFVVE9fUkVGUkVTSF9JTlRFUlZBTCA9IDQ1ICogNjAgKiAxMDAwOyAvLyA0NSBtaW51dGVzXHJcbiAgcHJpdmF0ZSBsYXN0UmVmcmVzaFRpbWU6IG51bWJlciA9IDA7IC8vIFRyYWNrIHdoZW4gYXV0by1yZWZyZXNoIHdhcyBsYXN0IHRyaWdnZXJlZFxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vIFN0YXJ0IGF1dG9tYXRpYyB0b2tlbiByZWZyZXNoXHJcbiAgICB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zdGFydEF1dG9SZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyXHJcbiAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRpbWVyKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hdXRvUmVmcmVzaFRpbWVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgdXAgYXV0b21hdGljIHJlZnJlc2ggZXZlcnkgNDUgbWludXRlc1xyXG4gICAgdGhpcy5hdXRvUmVmcmVzaFRpbWVyID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdBdXRvLXJlZnJlc2hpbmcgWm9obyB0b2tlbiAoNDUtbWludXRlIGludGVydmFsKS4uLicpO1xyXG4gICAgICAgIHRoaXMubGFzdFJlZnJlc2hUaW1lID0gRGF0ZS5ub3coKTsgLy8gVHJhY2sgd2hlbiByZWZyZXNoIHdhcyB0cmlnZ2VyZWRcclxuICAgICAgICBhd2FpdCB0aGlzLmZvcmNlUmVmcmVzaFRva2VuKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0F1dG8tcmVmcmVzaCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignQXV0by1yZWZyZXNoIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMuQVVUT19SRUZSRVNIX0lOVEVSVkFMKTtcclxuXHJcbiAgICAvLyBTZXQgaW5pdGlhbCByZWZyZXNoIHRpbWVcclxuICAgIHRoaXMubGFzdFJlZnJlc2hUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnNvbGUubG9nKCdBdXRvbWF0aWMgWm9obyB0b2tlbiByZWZyZXNoIHN0YXJ0ZWQgKGV2ZXJ5IDQ1IG1pbnV0ZXMpJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zdG9wQXV0b1JlZnJlc2goKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRpbWVyKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hdXRvUmVmcmVzaFRpbWVyKTtcclxuICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpbWVyID0gbnVsbDtcclxuICAgICAgY29uc29sZS5sb2coJ0F1dG9tYXRpYyBab2hvIHRva2VuIHJlZnJlc2ggc3RvcHBlZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRBY2Nlc3NUb2tlbigpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgc3RpbGwgdmFsaWQgKHdpdGggYnVmZmVyKVxyXG4gICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gJiYgRGF0ZS5ub3coKSA8ICh0aGlzLnRva2VuRXhwaXJ5IC0gdGhpcy5UT0tFTl9SRUZSRVNIX0JVRkZFUikpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlcmUncyBhbHJlYWR5IGEgcmVmcmVzaCBpbiBwcm9ncmVzcywgd2FpdCBmb3IgaXRcclxuICAgIGlmICh0aGlzLnJlZnJlc2hQcm9taXNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXJ0IGEgbmV3IHJlZnJlc2hcclxuICAgIHRoaXMucmVmcmVzaFByb21pc2UgPSB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLnJlZnJlc2hQcm9taXNlO1xyXG4gICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICB0aGlzLnJlZnJlc2hQcm9taXNlID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnUmVmcmVzaGluZyBab2hvIGFjY2VzcyB0b2tlbi4uLicpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIGZvcm0gZGF0YSBmb3IgdGhlIHJlcXVlc3RcclxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgncmVmcmVzaF90b2tlbicsIHByb2Nlc3MuZW52LlpPSE9fUkVGUkVTSF9UT0tFTiB8fCAnJyk7XHJcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnY2xpZW50X2lkJywgcHJvY2Vzcy5lbnYuWk9IT19DTElFTlRfSUQgfHwgJycpO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2NsaWVudF9zZWNyZXQnLCBwcm9jZXNzLmVudi5aT0hPX0NMSUVOVF9TRUNSRVQgfHwgJycpO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2dyYW50X3R5cGUnLCAncmVmcmVzaF90b2tlbicpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0PFRva2VuUmVzcG9uc2U+KCdodHRwczovL2FjY291bnRzLnpvaG8uY29tL29hdXRoL3YyL3Rva2VuJywgZm9ybURhdGEsIHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcmVzcG9uc2UuZGF0YS5hY2Nlc3NfdG9rZW47XHJcbiAgICAgIHRoaXMudG9rZW5FeHBpcnkgPSBEYXRlLm5vdygpICsgKHJlc3BvbnNlLmRhdGEuZXhwaXJlc19pbiAqIDEwMDApO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYFRva2VuIHJlZnJlc2hlZCBzdWNjZXNzZnVsbHkuIEV4cGlyZXMgaW4gJHtNYXRoLnJvdW5kKHJlc3BvbnNlLmRhdGEuZXhwaXJlc19pbiAvIDYwKX0gbWludXRlc2ApO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW47XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWZyZXNoaW5nIFpvaG8gYWNjZXNzIHRva2VuOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXV0aGVudGljYXRlIHdpdGggWm9obycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdChlbmRwb2ludDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgaHR0cHM6Ly93d3cuem9ob2FwaXMuY29tL2Jvb2tzL3YzLyR7ZW5kcG9pbnR9YCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICBvcmdhbml6YXRpb25faWQ6IHByb2Nlc3MuZW52LlpPSE9fT1JHQU5JWkFUSU9OX0lELFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIC8vIElmIHdlIGdldCBhIDQwMSwgdHJ5IHJlZnJlc2hpbmcgdGhlIHRva2VuIG9uY2VcclxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUb2tlbiBleHBpcmVkLCByZWZyZXNoaW5nLi4uJyk7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b2tlbkV4cGlyeSA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbmV3VG9rZW4gPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgbmV3IHRva2VuXHJcbiAgICAgICAgY29uc3QgcmV0cnlSZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgaHR0cHM6Ly93d3cuem9ob2FwaXMuY29tL2Jvb2tzL3YzLyR7ZW5kcG9pbnR9YCwge1xyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtuZXdUb2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICBvcmdhbml6YXRpb25faWQ6IHByb2Nlc3MuZW52LlpPSE9fT1JHQU5JWkFUSU9OX0lELFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmV0cnlSZXNwb25zZS5kYXRhO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBtYWtpbmcgWm9obyByZXF1ZXN0IHRvICR7ZW5kcG9pbnR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIFpvaG86ICR7ZW5kcG9pbnR9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0cygpOiBQcm9taXNlPFpvaG9Qcm9qZWN0W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCBhbGxQcm9qZWN0czogWm9ob1Byb2plY3RbXSA9IFtdO1xyXG4gICAgICBsZXQgcGFnZSA9IDE7XHJcbiAgICAgIGNvbnN0IHBlclBhZ2UgPSAyMDA7XHJcbiAgICAgIFxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGBwcm9qZWN0cz9wYWdlPSR7cGFnZX0mcGVyX3BhZ2U9JHtwZXJQYWdlfWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHByb2plY3RzID0gZGF0YS5wcm9qZWN0cz8ubWFwKChwcm9qZWN0OiBhbnkpID0+IHtcclxuICAgICAgICAgIC8vIExvZyB0aGUgZmlyc3QgcHJvamVjdCB0byBzZWUgYXZhaWxhYmxlIGZpZWxkc1xyXG4gICAgICAgICAgaWYgKHBhZ2UgPT09IDEgJiYgYWxsUHJvamVjdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTYW1wbGUgWm9obyBwcm9qZWN0IGRhdGE6JywgSlNPTi5zdHJpbmdpZnkocHJvamVjdCwgbnVsbCwgMikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9qZWN0X2lkOiBwcm9qZWN0LnByb2plY3RfaWQsXHJcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdC5wcm9qZWN0X25hbWUgfHwgcHJvamVjdC5uYW1lIHx8ICcnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcHJvamVjdC5kZXNjcmlwdGlvbiB8fCAnJyxcclxuICAgICAgICAgICAgc3RhdHVzOiBwcm9qZWN0LnN0YXR1cyB8fCAnYWN0aXZlJyxcclxuICAgICAgICAgICAgc3RhcnRfZGF0ZTogcHJvamVjdC5zdGFydF9kYXRlIHx8ICcnLFxyXG4gICAgICAgICAgICBlbmRfZGF0ZTogcHJvamVjdC5lbmRfZGF0ZSB8fCAnJyxcclxuICAgICAgICAgICAgYnVkZ2V0X2Ftb3VudDogcHJvamVjdC5idWRnZXRfYW1vdW50IHx8IDAsXHJcbiAgICAgICAgICAgIHJhdGVfcGVyX2hvdXI6IHByb2plY3QucmF0ZV9wZXJfaG91ciB8fCAwLFxyXG4gICAgICAgICAgICBjdXN0b21lcl9pZDogcHJvamVjdC5jdXN0b21lcl9pZCB8fCAnJyxcclxuICAgICAgICAgICAgY3VzdG9tZXJfbmFtZTogcHJvamVjdC5jdXN0b21lcl9uYW1lIHx8ICcnLFxyXG4gICAgICAgICAgICBzaWduZWRfZmVlOiB1bmRlZmluZWQsIC8vIFJlbW92ZSBab2hvIHNpZ25lZCBmZWUsIG9ubHkgdXNlIHVzZXItZW50ZXJlZCBkYXRhXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pIHx8IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGFsbFByb2plY3RzID0gYWxsUHJvamVjdHMuY29uY2F0KHByb2plY3RzKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcclxuICAgICAgICBpZiAocHJvamVjdHMubGVuZ3RoIDwgcGVyUGFnZSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHBhZ2UrKztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgJHthbGxQcm9qZWN0cy5sZW5ndGh9IHByb2plY3RzIGZyb20gWm9ob2ApO1xyXG4gICAgICByZXR1cm4gYWxsUHJvamVjdHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0czonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RzV2l0aFJldmVudWVCdWRnZXQoKTogUHJvbWlzZTxab2hvUHJvamVjdFtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgcHJvamVjdHMgd2l0aCByZXZlbnVlIGJ1ZGdldCBkYXRhLi4uJyk7XHJcbiAgICAgIGNvbnN0IHByb2plY3RzID0gYXdhaXQgdGhpcy5nZXRQcm9qZWN0cygpO1xyXG4gICAgICBcclxuICAgICAgLy8gTG9nIHByb2plY3RzIHRoYXQgaGF2ZSByZXZlbnVlX2J1ZGdldCBkYXRhXHJcbiAgICAgIGNvbnN0IHByb2plY3RzV2l0aFJldmVudWVCdWRnZXQgPSBwcm9qZWN0cy5maWx0ZXIocHJvamVjdCA9PiB7XHJcbiAgICAgICAgY29uc3QgaGFzUmV2ZW51ZUJ1ZGdldCA9IHByb2plY3Quc2lnbmVkX2ZlZSAmJiBwcm9qZWN0LnNpZ25lZF9mZWUgPiAwO1xyXG4gICAgICAgIGlmIChoYXNSZXZlbnVlQnVkZ2V0KSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvamVjdCAke3Byb2plY3QucHJvamVjdF9uYW1lfSBoYXMgcmV2ZW51ZSBidWRnZXQ6ICQke3Byb2plY3Quc2lnbmVkX2ZlZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc1JldmVudWVCdWRnZXQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7cHJvamVjdHNXaXRoUmV2ZW51ZUJ1ZGdldC5sZW5ndGh9IHByb2plY3RzIHdpdGggcmV2ZW51ZSBidWRnZXQgZGF0YWApO1xyXG4gICAgICByZXR1cm4gcHJvamVjdHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0cyB3aXRoIHJldmVudWUgYnVkZ2V0OicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVidWdQcm9qZWN0RmllbGRzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0RlYnVnZ2luZyBab2hvIHByb2plY3QgZmllbGRzLi4uJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCdwcm9qZWN0cz9wYWdlPTEmcGVyX3BhZ2U9NScpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGRhdGEucHJvamVjdHMgJiYgZGF0YS5wcm9qZWN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0F2YWlsYWJsZSBmaWVsZHMgaW4gWm9obyBwcm9qZWN0IHJlc3BvbnNlOicpO1xyXG4gICAgICAgIGNvbnN0IHNhbXBsZVByb2plY3QgPSBkYXRhLnByb2plY3RzWzBdO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHNhbXBsZVByb2plY3QpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICR7a2V5fTogJHtzYW1wbGVQcm9qZWN0W2tleV19ICgke3R5cGVvZiBzYW1wbGVQcm9qZWN0W2tleV19KWApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIHNwZWNpZmljYWxseSBmb3IgcmV2ZW51ZV9idWRnZXRcclxuICAgICAgICBpZiAoc2FtcGxlUHJvamVjdC5yZXZlbnVlX2J1ZGdldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIHJldmVudWVfYnVkZ2V0IGZpZWxkOiAke3NhbXBsZVByb2plY3QucmV2ZW51ZV9idWRnZXR9YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgcmV2ZW51ZV9idWRnZXQgZmllbGQgbm90IGZvdW5kIGluIFpvaG8gcmVzcG9uc2UnKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdBdmFpbGFibGUgYnVkZ2V0LXJlbGF0ZWQgZmllbGRzOicpO1xyXG4gICAgICAgICAgT2JqZWN0LmtleXMoc2FtcGxlUHJvamVjdCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2J1ZGdldCcpIHx8IGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyZXZlbnVlJykpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAke2tleX06ICR7c2FtcGxlUHJvamVjdFtrZXldfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ05vIHByb2plY3RzIGZvdW5kIGluIFpvaG8gcmVzcG9uc2UnKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVidWdnaW5nIHByb2plY3QgZmllbGRzOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RzV2l0aEVzdGltYXRlcygpOiBQcm9taXNlPFpvaG9Qcm9qZWN0W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHByb2plY3RzID0gYXdhaXQgdGhpcy5nZXRQcm9qZWN0cygpO1xyXG4gICAgICBcclxuICAgICAgLy8gRm9yIHRoZSBmaXJzdCBmZXcgcHJvamVjdHMsIHRyeSB0byBnZXQgZXN0aW1hdGVzIHRvIHNlZSBpZiB0aGF0IGNvbnRhaW5zIHRoZSBzaWduZWQgZmVlXHJcbiAgICAgIGNvbnN0IHByb2plY3RzV2l0aEVzdGltYXRlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgIHByb2plY3RzLnNsaWNlKDAsIDUpLm1hcChhc3luYyAocHJvamVjdCkgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVzID0gYXdhaXQgdGhpcy5nZXRQcm9qZWN0RXN0aW1hdGVzKHByb2plY3QucHJvamVjdF9pZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRXN0aW1hdGVBbW91bnQgPSBlc3RpbWF0ZXMucmVkdWNlKChzdW0sIGVzdGltYXRlKSA9PiBzdW0gKyAoZXN0aW1hdGUudG90YWwgfHwgMCksIDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2plY3QgJHtwcm9qZWN0LnByb2plY3RfbmFtZX0gZXN0aW1hdGVzOmAsIGVzdGltYXRlcy5sZW5ndGgsICd0b3RhbCBhbW91bnQ6JywgdG90YWxFc3RpbWF0ZUFtb3VudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnByb2plY3QsXHJcbiAgICAgICAgICAgICAgc2lnbmVkX2ZlZTogcHJvamVjdC5zaWduZWRfZmVlIHx8IHRvdGFsRXN0aW1hdGVBbW91bnQgfHwgMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGVzdGltYXRlcyBmb3IgcHJvamVjdCAke3Byb2plY3QucHJvamVjdF9pZH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgLy8gUmV0dXJuIGFsbCBwcm9qZWN0cywgd2l0aCB0aGUgZmlyc3QgNSBoYXZpbmcgdXBkYXRlZCBzaWduZWQgZmVlcyBmcm9tIGVzdGltYXRlc1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIC4uLnByb2plY3RzV2l0aEVzdGltYXRlcyxcclxuICAgICAgICAuLi5wcm9qZWN0cy5zbGljZSg1KVxyXG4gICAgICBdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHMgd2l0aCBlc3RpbWF0ZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0c1dpdGhJbnZvaWNlVG90YWxzKCk6IFByb21pc2U8Wm9ob1Byb2plY3RbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgW3Byb2plY3RzLCBpbnZvaWNlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0cygpLFxyXG4gICAgICAgIHRoaXMuZ2V0SW52b2ljZXMoKSxcclxuICAgICAgXSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDYWxjdWxhdGUgc2lnbmVkIGZlZSBhcyB0b3RhbCBvZiBhbGwgaW52b2ljZXMgZm9yIGVhY2ggcHJvamVjdFxyXG4gICAgICBjb25zdCBwcm9qZWN0c1dpdGhJbnZvaWNlVG90YWxzID0gcHJvamVjdHMubWFwKHByb2plY3QgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb2plY3RJbnZvaWNlcyA9IGludm9pY2VzLmZpbHRlcihpbnZvaWNlID0+IGludm9pY2UucHJvamVjdF9pZCA9PT0gcHJvamVjdC5wcm9qZWN0X2lkKTtcclxuICAgICAgICBjb25zdCB0b3RhbEludm9pY2VBbW91bnQgPSBwcm9qZWN0SW52b2ljZXMucmVkdWNlKChzdW0sIGludm9pY2UpID0+IHN1bSArIGludm9pY2UuYW1vdW50LCAwKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvamVjdCAke3Byb2plY3QucHJvamVjdF9uYW1lfSBpbnZvaWNlczpgLCBwcm9qZWN0SW52b2ljZXMubGVuZ3RoLCAndG90YWwgYW1vdW50OicsIHRvdGFsSW52b2ljZUFtb3VudCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLnByb2plY3QsXHJcbiAgICAgICAgICBzaWduZWRfZmVlOiBwcm9qZWN0LnNpZ25lZF9mZWUgfHwgdG90YWxJbnZvaWNlQW1vdW50IHx8IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gcHJvamVjdHNXaXRoSW52b2ljZVRvdGFscztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3RzIHdpdGggaW52b2ljZSB0b3RhbHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRJbnZvaWNlcygpOiBQcm9taXNlPFpvaG9JbnZvaWNlW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCdpbnZvaWNlcycpO1xyXG4gICAgICByZXR1cm4gZGF0YS5pbnZvaWNlcz8ubWFwKChpbnZvaWNlOiBhbnkpID0+ICh7XHJcbiAgICAgICAgaW52b2ljZV9pZDogaW52b2ljZS5pbnZvaWNlX2lkLFxyXG4gICAgICAgIHByb2plY3RfaWQ6IGludm9pY2UucHJvamVjdF9pZCxcclxuICAgICAgICBpbnZvaWNlX251bWJlcjogaW52b2ljZS5pbnZvaWNlX251bWJlcixcclxuICAgICAgICBkYXRlOiBpbnZvaWNlLmRhdGUsXHJcbiAgICAgICAgYW1vdW50OiBpbnZvaWNlLnRvdGFsLFxyXG4gICAgICAgIHN0YXR1czogaW52b2ljZS5zdGF0dXMsXHJcbiAgICAgICAgYmlsbGVkX2Ftb3VudDogaW52b2ljZS5iaWxsZWRfYW1vdW50IHx8IDAsXHJcbiAgICAgICAgdW5iaWxsZWRfYW1vdW50OiBpbnZvaWNlLnVuYmlsbGVkX2Ftb3VudCB8fCAwLFxyXG4gICAgICB9KSkgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBpbnZvaWNlczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RJbnZvaWNlcyhwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8Wm9ob0ludm9pY2VbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHByb2plY3RzLyR7cHJvamVjdElkfS9pbnZvaWNlc2ApO1xyXG4gICAgICByZXR1cm4gZGF0YS5pbnZvaWNlcz8ubWFwKChpbnZvaWNlOiBhbnkpID0+ICh7XHJcbiAgICAgICAgaW52b2ljZV9pZDogaW52b2ljZS5pbnZvaWNlX2lkLFxyXG4gICAgICAgIHByb2plY3RfaWQ6IGludm9pY2UucHJvamVjdF9pZCxcclxuICAgICAgICBpbnZvaWNlX251bWJlcjogaW52b2ljZS5pbnZvaWNlX251bWJlcixcclxuICAgICAgICBkYXRlOiBpbnZvaWNlLmRhdGUsXHJcbiAgICAgICAgYW1vdW50OiBpbnZvaWNlLnRvdGFsLFxyXG4gICAgICAgIHN0YXR1czogaW52b2ljZS5zdGF0dXMsXHJcbiAgICAgICAgYmlsbGVkX2Ftb3VudDogaW52b2ljZS5iaWxsZWRfYW1vdW50IHx8IDAsXHJcbiAgICAgICAgdW5iaWxsZWRfYW1vdW50OiBpbnZvaWNlLnVuYmlsbGVkX2Ftb3VudCB8fCAwLFxyXG4gICAgICB9KSkgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0IGludm9pY2VzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdERldGFpbHMocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHByb2plY3RzLyR7cHJvamVjdElkfWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgUHJvamVjdCAke3Byb2plY3RJZH0gZGV0YWlsczpgLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdCBkZXRhaWxzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0RXN0aW1hdGVzKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHByb2plY3RzLyR7cHJvamVjdElkfS9lc3RpbWF0ZXNgKTtcclxuICAgICAgY29uc29sZS5sb2coYFByb2plY3QgJHtwcm9qZWN0SWR9IGVzdGltYXRlczpgLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhLmVzdGltYXRlcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3QgZXN0aW1hdGVzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdENvbnRyYWN0cyhwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGBwcm9qZWN0cy8ke3Byb2plY3RJZH0vY29udHJhY3RzYCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9qZWN0ICR7cHJvamVjdElkfSBjb250cmFjdHM6YCwgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xyXG4gICAgICByZXR1cm4gZGF0YS5jb250cmFjdHMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9qZWN0IGNvbnRyYWN0czonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5ldyBtZXRob2QgdG8gZ2V0IFByb2ZpdCAmIExvc3Mgc3RhdGVtZW50XHJcbiAgYXN5bmMgZ2V0UHJvZml0QW5kTG9zcyhzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGByZXBvcnRzL3Byb2ZpdGFuZGxvc3M/ZnJvbV9kYXRlPSR7c3RhcnREYXRlfSZ0b19kYXRlPSR7ZW5kRGF0ZX1gKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Byb2ZpdCAmIExvc3MgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgUHJvZml0ICYgTG9zczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTmV3IG1ldGhvZCB0byBnZXQgQ2FzaCBGbG93IHN0YXRlbWVudFxyXG4gIGFzeW5jIGdldENhc2hGbG93KHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYHJlcG9ydHMvY2FzaGZsb3c/ZnJvbV9kYXRlPSR7c3RhcnREYXRlfSZ0b19kYXRlPSR7ZW5kRGF0ZX1gKTtcclxuICAgICAgY29uc29sZS5sb2coJ0Nhc2ggRmxvdyBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBDYXNoIEZsb3c6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5ldyBtZXRob2QgdG8gZ2V0IEJhbGFuY2UgU2hlZXRcclxuICBhc3luYyBnZXRCYWxhbmNlU2hlZXQoZGF0ZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGByZXBvcnRzL2JhbGFuY2VzaGVldD9kYXRlPSR7ZGF0ZX1gKTtcclxuICAgICAgY29uc29sZS5sb2coJ0JhbGFuY2UgU2hlZXQgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgQmFsYW5jZSBTaGVldDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTmV3IG1ldGhvZCB0byBnZXQgQ2hhcnQgb2YgQWNjb3VudHNcclxuICBhc3luYyBnZXRDaGFydE9mQWNjb3VudHMoKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJ2NoYXJ0b2ZhY2NvdW50cycpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQ2hhcnQgb2YgQWNjb3VudHMgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhLmNoYXJ0b2ZhY2NvdW50cyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIENoYXJ0IG9mIEFjY291bnRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTmV3IG1ldGhvZCB0byBnZXQgSm91cm5hbCBFbnRyaWVzIGZvciBhIGRhdGUgcmFuZ2VcclxuICBhc3luYyBnZXRKb3VybmFsRW50cmllcyhzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYGpvdXJuYWxlbnRyaWVzP2Zyb21fZGF0ZT0ke3N0YXJ0RGF0ZX0mdG9fZGF0ZT0ke2VuZERhdGV9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdKb3VybmFsIEVudHJpZXMgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XHJcbiAgICAgIHJldHVybiBkYXRhLmpvdXJuYWxlbnRyaWVzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgSm91cm5hbCBFbnRyaWVzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTmV3IG1ldGhvZCB0byBnZXQgY29tcHJlaGVuc2l2ZSBmaW5hbmNpYWwgbWV0cmljc1xyXG4gIGFzeW5jIGdldEZpbmFuY2lhbE1ldHJpY3Moc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgcmV2ZW51ZTogbnVtYmVyO1xyXG4gICAgZXhwZW5zZXM6IG51bWJlcjtcclxuICAgIGdyb3NzUHJvZml0OiBudW1iZXI7XHJcbiAgICBuZXRQcm9maXQ6IG51bWJlcjtcclxuICAgIG9wZXJhdGluZ0luY29tZTogbnVtYmVyO1xyXG4gICAgY2FzaEZsb3c6IG51bWJlcjtcclxuICAgIGFjY291bnRzUmVjZWl2YWJsZTogbnVtYmVyO1xyXG4gICAgYWNjb3VudHNQYXlhYmxlOiBudW1iZXI7XHJcbiAgICBjYXNoQmFsYW5jZTogbnVtYmVyO1xyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IFtwbERhdGEsIGNmRGF0YSwgYnNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICB0aGlzLmdldFByb2ZpdEFuZExvc3Moc3RhcnREYXRlLCBlbmREYXRlKSxcclxuICAgICAgICB0aGlzLmdldENhc2hGbG93KHN0YXJ0RGF0ZSwgZW5kRGF0ZSksXHJcbiAgICAgICAgdGhpcy5nZXRCYWxhbmNlU2hlZXQoZW5kRGF0ZSlcclxuICAgICAgXSk7XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IGZpbmFuY2lhbCBtZXRyaWNzIGZyb20gdGhlIHJlc3BvbnNlc1xyXG4gICAgICBjb25zdCByZXZlbnVlID0gcGxEYXRhPy5yZXZlbnVlPy50b3RhbCB8fCAwO1xyXG4gICAgICBjb25zdCBleHBlbnNlcyA9IHBsRGF0YT8uZXhwZW5zZXM/LnRvdGFsIHx8IDA7XHJcbiAgICAgIGNvbnN0IGdyb3NzUHJvZml0ID0gcmV2ZW51ZSAtIGV4cGVuc2VzO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldCBwcm9maXQgKG1heSBuZWVkIGFkanVzdG1lbnQgYmFzZWQgb24gYWN0dWFsIFpvaG8gcmVzcG9uc2Ugc3RydWN0dXJlKVxyXG4gICAgICBjb25zdCBuZXRQcm9maXQgPSBncm9zc1Byb2ZpdCAtIChwbERhdGE/Lm9wZXJhdGluZ19leHBlbnNlcz8udG90YWwgfHwgMCk7XHJcbiAgICAgIGNvbnN0IG9wZXJhdGluZ0luY29tZSA9IGdyb3NzUHJvZml0IC0gKHBsRGF0YT8ub3BlcmF0aW5nX2V4cGVuc2VzPy50b3RhbCB8fCAwKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgY2FzaCBmbG93IGRhdGFcclxuICAgICAgY29uc3QgY2FzaEZsb3cgPSBjZkRhdGE/Lm5ldF9jYXNoX2Zsb3cgfHwgMDtcclxuICAgICAgY29uc3QgYWNjb3VudHNSZWNlaXZhYmxlID0gYnNEYXRhPy5jdXJyZW50X2Fzc2V0cz8uYWNjb3VudHNfcmVjZWl2YWJsZSB8fCAwO1xyXG4gICAgICBjb25zdCBhY2NvdW50c1BheWFibGUgPSBic0RhdGE/LmN1cnJlbnRfbGlhYmlsaXRpZXM/LmFjY291bnRzX3BheWFibGUgfHwgMDtcclxuICAgICAgY29uc3QgY2FzaEJhbGFuY2UgPSBic0RhdGE/LmN1cnJlbnRfYXNzZXRzPy5jYXNoX2FuZF9iYW5rIHx8IDA7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJldmVudWUsXHJcbiAgICAgICAgZXhwZW5zZXMsXHJcbiAgICAgICAgZ3Jvc3NQcm9maXQsXHJcbiAgICAgICAgbmV0UHJvZml0LFxyXG4gICAgICAgIG9wZXJhdGluZ0luY29tZSxcclxuICAgICAgICBjYXNoRmxvdyxcclxuICAgICAgICBhY2NvdW50c1JlY2VpdmFibGUsXHJcbiAgICAgICAgYWNjb3VudHNQYXlhYmxlLFxyXG4gICAgICAgIGNhc2hCYWxhbmNlXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmaW5hbmNpYWwgbWV0cmljczonLCBlcnJvcik7XHJcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IHZhbHVlcyBpZiBBUEkgY2FsbHMgZmFpbFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJldmVudWU6IDAsXHJcbiAgICAgICAgZXhwZW5zZXM6IDAsXHJcbiAgICAgICAgZ3Jvc3NQcm9maXQ6IDAsXHJcbiAgICAgICAgbmV0UHJvZml0OiAwLFxyXG4gICAgICAgIG9wZXJhdGluZ0luY29tZTogMCxcclxuICAgICAgICBjYXNoRmxvdzogMCxcclxuICAgICAgICBhY2NvdW50c1JlY2VpdmFibGU6IDAsXHJcbiAgICAgICAgYWNjb3VudHNQYXlhYmxlOiAwLFxyXG4gICAgICAgIGNhc2hCYWxhbmNlOiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNZXRob2QgdG8gbWFudWFsbHkgcmVmcmVzaCB0b2tlbiAoZm9yIHRlc3RpbmcpXHJcbiAgYXN5bmMgZm9yY2VSZWZyZXNoVG9rZW4oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcclxuICAgIHRoaXMudG9rZW5FeHBpcnkgPSAwO1xyXG4gICAgdGhpcy5sYXN0UmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpOyAvLyBUcmFjayBtYW51YWwgcmVmcmVzaCB0aW1lXHJcbiAgICBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdG9rZW4gc3RhdHVzIGZvciBkZWJ1Z2dpbmdcclxuICBnZXRUb2tlblN0YXR1cygpOiB7IGhhc1Rva2VuOiBib29sZWFuOyBleHBpcmVzSW46IG51bWJlcjsgaXNFeHBpcmVkOiBib29sZWFuIH0ge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGhhc1Rva2VuOiAhIXRoaXMuYWNjZXNzVG9rZW4sXHJcbiAgICAgIGV4cGlyZXNJbjogdGhpcy50b2tlbkV4cGlyeSAtIG5vdyxcclxuICAgICAgaXNFeHBpcmVkOiBub3cgPj0gdGhpcy50b2tlbkV4cGlyeSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBNZXRob2QgdG8gZ2V0IGF1dG8tcmVmcmVzaCBzdGF0dXNcclxuICBnZXRBdXRvUmVmcmVzaFN0YXR1cygpOiB7IGlzQWN0aXZlOiBib29sZWFuOyBuZXh0UmVmcmVzaEluOiBudW1iZXIgfSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgdGltZVNpbmNlTGFzdFJlZnJlc2ggPSBub3cgLSB0aGlzLmxhc3RSZWZyZXNoVGltZTtcclxuICAgIGNvbnN0IG5leHRSZWZyZXNoSW4gPSBNYXRoLm1heCgwLCB0aGlzLkFVVE9fUkVGUkVTSF9JTlRFUlZBTCAtIHRpbWVTaW5jZUxhc3RSZWZyZXNoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNBY3RpdmU6ICEhdGhpcy5hdXRvUmVmcmVzaFRpbWVyLFxyXG4gICAgICBuZXh0UmVmcmVzaEluLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYyBtZXRob2QgdG8gc3RhcnQgYXV0by1yZWZyZXNoXHJcbiAgZW5hYmxlQXV0b1JlZnJlc2goKTogdm9pZCB7XHJcbiAgICB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWMgbWV0aG9kIHRvIHN0b3AgYXV0by1yZWZyZXNoXHJcbiAgZGlzYWJsZUF1dG9SZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWMgbWV0aG9kIHRvIGdldCBjb21wcmVoZW5zaXZlIHN0YXR1c1xyXG4gIGdldFN0YXR1cygpOiB7IFxyXG4gICAgaGFzVG9rZW46IGJvb2xlYW47IFxyXG4gICAgZXhwaXJlc0luOiBudW1iZXI7IFxyXG4gICAgaXNFeHBpcmVkOiBib29sZWFuO1xyXG4gICAgYXV0b1JlZnJlc2g6IHsgaXNBY3RpdmU6IGJvb2xlYW47IG5leHRSZWZyZXNoSW46IG51bWJlciB9O1xyXG4gIH0ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4udGhpcy5nZXRUb2tlblN0YXR1cygpLFxyXG4gICAgICBhdXRvUmVmcmVzaDogdGhpcy5nZXRBdXRvUmVmcmVzaFN0YXR1cygpLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB6b2hvU2VydmljZSA9IG5ldyBab2hvU2VydmljZSgpOyBcclxuXHJcbi8vIEV4cG9ydCB0aGUgZnVuY3Rpb25zIHRoYXQgYXJlIGJlaW5nIGltcG9ydGVkIGluIHBhZ2UudHN4XHJcbmV4cG9ydCBjb25zdCBmZXRjaFByb2plY3RzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnQ2xpZW50OiBGZXRjaGluZyBwcm9qZWN0cyBmcm9tIEFQSScpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wcm9qZWN0cycpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgXHJcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0NsaWVudDogU3VjY2Vzc2Z1bGx5IGZldGNoZWQnLCByZXN1bHQuY291bnQsICdwcm9qZWN0cycpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdDbGllbnQ6IEFQSSByZXR1cm5lZCBlcnJvcjonLCByZXN1bHQuZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQ2xpZW50OiBFcnJvciBmZXRjaGluZyBwcm9qZWN0czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmV0Y2hJbnZvaWNlcyA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ0NsaWVudDogRmV0Y2hpbmcgaW52b2ljZXMgZnJvbSBBUEknKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvaW52b2ljZXMnKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDbGllbnQ6IFN1Y2Nlc3NmdWxseSBmZXRjaGVkJywgcmVzdWx0LmNvdW50LCAnaW52b2ljZXMnKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQ2xpZW50OiBBUEkgcmV0dXJuZWQgZXJyb3I6JywgcmVzdWx0LmVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvcik7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NsaWVudDogRXJyb3IgZmV0Y2hpbmcgaW52b2ljZXM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59OyAiXSwibmFtZXMiOlsiYXhpb3MiLCJab2hvU2VydmljZSIsIl9zdGFydEF1dG9SZWZyZXNoIiwiYXV0b1JlZnJlc2hUaW1lciIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNvbnNvbGUiLCJsb2ciLCJsYXN0UmVmcmVzaFRpbWUiLCJEYXRlIiwibm93IiwiZm9yY2VSZWZyZXNoVG9rZW4iLCJlcnJvciIsIkFVVE9fUkVGUkVTSF9JTlRFUlZBTCIsIl9zdG9wQXV0b1JlZnJlc2giLCJnZXRBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwidG9rZW5FeHBpcnkiLCJUT0tFTl9SRUZSRVNIX0JVRkZFUiIsInJlZnJlc2hQcm9taXNlIiwicmVmcmVzaEFjY2Vzc1Rva2VuIiwidG9rZW4iLCJmb3JtRGF0YSIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInByb2Nlc3MiLCJlbnYiLCJaT0hPX1JFRlJFU0hfVE9LRU4iLCJaT0hPX0NMSUVOVF9JRCIsIlpPSE9fQ0xJRU5UX1NFQ1JFVCIsInJlc3BvbnNlIiwicG9zdCIsImhlYWRlcnMiLCJkYXRhIiwiYWNjZXNzX3Rva2VuIiwiZXhwaXJlc19pbiIsIk1hdGgiLCJyb3VuZCIsIkVycm9yIiwibWFrZVJlcXVlc3QiLCJlbmRwb2ludCIsImdldCIsInBhcmFtcyIsIm9yZ2FuaXphdGlvbl9pZCIsIlpPSE9fT1JHQU5JWkFUSU9OX0lEIiwic3RhdHVzIiwibmV3VG9rZW4iLCJyZXRyeVJlc3BvbnNlIiwiZ2V0UHJvamVjdHMiLCJhbGxQcm9qZWN0cyIsInBhZ2UiLCJwZXJQYWdlIiwicHJvamVjdHMiLCJtYXAiLCJwcm9qZWN0IiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsInByb2plY3RfaWQiLCJwcm9qZWN0X25hbWUiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJidWRnZXRfYW1vdW50IiwicmF0ZV9wZXJfaG91ciIsImN1c3RvbWVyX2lkIiwiY3VzdG9tZXJfbmFtZSIsInNpZ25lZF9mZWUiLCJ1bmRlZmluZWQiLCJjb25jYXQiLCJnZXRQcm9qZWN0c1dpdGhSZXZlbnVlQnVkZ2V0IiwicHJvamVjdHNXaXRoUmV2ZW51ZUJ1ZGdldCIsImZpbHRlciIsImhhc1JldmVudWVCdWRnZXQiLCJkZWJ1Z1Byb2plY3RGaWVsZHMiLCJzYW1wbGVQcm9qZWN0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJyZXZlbnVlX2J1ZGdldCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJnZXRQcm9qZWN0c1dpdGhFc3RpbWF0ZXMiLCJwcm9qZWN0c1dpdGhFc3RpbWF0ZXMiLCJQcm9taXNlIiwiYWxsIiwic2xpY2UiLCJlc3RpbWF0ZXMiLCJnZXRQcm9qZWN0RXN0aW1hdGVzIiwidG90YWxFc3RpbWF0ZUFtb3VudCIsInJlZHVjZSIsInN1bSIsImVzdGltYXRlIiwidG90YWwiLCJnZXRQcm9qZWN0c1dpdGhJbnZvaWNlVG90YWxzIiwiaW52b2ljZXMiLCJnZXRJbnZvaWNlcyIsInByb2plY3RzV2l0aEludm9pY2VUb3RhbHMiLCJwcm9qZWN0SW52b2ljZXMiLCJpbnZvaWNlIiwidG90YWxJbnZvaWNlQW1vdW50IiwiYW1vdW50IiwiaW52b2ljZV9pZCIsImludm9pY2VfbnVtYmVyIiwiZGF0ZSIsImJpbGxlZF9hbW91bnQiLCJ1bmJpbGxlZF9hbW91bnQiLCJnZXRQcm9qZWN0SW52b2ljZXMiLCJwcm9qZWN0SWQiLCJnZXRQcm9qZWN0RGV0YWlscyIsImdldFByb2plY3RDb250cmFjdHMiLCJjb250cmFjdHMiLCJnZXRQcm9maXRBbmRMb3NzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImdldENhc2hGbG93IiwiZ2V0QmFsYW5jZVNoZWV0IiwiZ2V0Q2hhcnRPZkFjY291bnRzIiwiY2hhcnRvZmFjY291bnRzIiwiZ2V0Sm91cm5hbEVudHJpZXMiLCJqb3VybmFsZW50cmllcyIsImdldEZpbmFuY2lhbE1ldHJpY3MiLCJwbERhdGEiLCJic0RhdGEiLCJjZkRhdGEiLCJyZXZlbnVlIiwiZXhwZW5zZXMiLCJncm9zc1Byb2ZpdCIsIm5ldFByb2ZpdCIsIm9wZXJhdGluZ19leHBlbnNlcyIsIm9wZXJhdGluZ0luY29tZSIsImNhc2hGbG93IiwibmV0X2Nhc2hfZmxvdyIsImFjY291bnRzUmVjZWl2YWJsZSIsImN1cnJlbnRfYXNzZXRzIiwiYWNjb3VudHNfcmVjZWl2YWJsZSIsImFjY291bnRzUGF5YWJsZSIsImN1cnJlbnRfbGlhYmlsaXRpZXMiLCJhY2NvdW50c19wYXlhYmxlIiwiY2FzaEJhbGFuY2UiLCJjYXNoX2FuZF9iYW5rIiwiZ2V0VG9rZW5TdGF0dXMiLCJoYXNUb2tlbiIsImV4cGlyZXNJbiIsImlzRXhwaXJlZCIsImdldEF1dG9SZWZyZXNoU3RhdHVzIiwidGltZVNpbmNlTGFzdFJlZnJlc2giLCJuZXh0UmVmcmVzaEluIiwibWF4IiwiaXNBY3RpdmUiLCJlbmFibGVBdXRvUmVmcmVzaCIsImRpc2FibGVBdXRvUmVmcmVzaCIsImdldFN0YXR1cyIsImF1dG9SZWZyZXNoIiwiY29uc3RydWN0b3IiLCJ6b2hvU2VydmljZSIsImZldGNoUHJvamVjdHMiLCJmZXRjaCIsInJlc3VsdCIsImpzb24iLCJzdWNjZXNzIiwiY291bnQiLCJmZXRjaEludm9pY2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/zoho.ts\n"));

/***/ })

});